[{"title":"Git commit之后撤销commit","path":"/2024/02/06/Gitcommit之后撤销commit.html","content":"撤销写完代码后，我们一般这样 123git add . //添加所有文件git commit -m &quot;本功能全部完成&quot; 执行完commit后，想撤回commit，怎么办？ 1git reset --soft HEAD^ 这样就成功的撤销了你的commit。 注意，仅仅是撤回commit操作，您写的代码仍然保留。HEAD^的意思是上一个版本，也可以写成HEAD~1,如果你进行了2次commit，想都撤回，可以使用HEAD~2。 参数 --mixed 意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作这个为默认参数,git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的。 --soft 不删除工作空间改动代码，撤销commit，不撤销git add . --hard 删除工作空间改动代码，撤销commit，撤销git add . 注意完成这个操作后，就恢复到了上一次的commit状态。 --amend1git commit --amend 如果commit注释写错了，只是想改一下注释，此时会进入默认vim编辑器，修改注释完毕后保存就好了。","tags":["Git"],"categories":["Git"]},{"title":"Git代码量统计常用命令","path":"/2024/02/04/Git代码量统计常用命令.html","content":"一、Git统计代码量1.根据用户名时间段统计123git log --author=&quot;username&quot; --since=2018-01-01 --until=2019-12-31 \\--pretty=tformat: --numstat | awk &#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; \\END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s &quot;, add, subs, loc &#125;&#x27; 2.查看提交者排名前N位1git log --pretty=&#x27;%aN&#x27; | sort | uniq -c | sort -k1 -n -r | head -n 5 3.提交数统计1git log --oneline | wc -l 4.根据用户名统计123git log --author=&quot;username&quot; --pretty=tformat: --numstat | awk &#x27;&#123; add += $1; \\subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s &quot;, add, subs, loc &#125;&#x27; 5.根据时间段统计123git log --since=2020-01-01 --until=2021-02-04 --pretty=tformat: --numstat \\ | awk &#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, \\ removed lines: %s, total lines: %s &quot;, add, subs, loc &#125;&#x27; 6.统计每个人的增删行数1234git log --format=&#x27;%aN&#x27; | sort -u | while read name; do echo -en &quot;$name\\t&quot;; \\git log --author=&quot;$name&quot; --pretty=tformat: --numstat | awk &#x27;&#123; add += $1; subs += $2; \\loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s &quot;, \\ add, subs, loc &#125;&#x27; -; done 7.贡献者统计1git log --pretty=&#x27;%aN&#x27; | sort -u | wc -l 8.根据时间段排除文件夹统计123git log --since=2021-01-28 --until=2021-02-03 --pretty=tformat: --numstat \\-- . &quot;:(exclude)src/test&quot; | awk &#x27;&#123; add += $1; subs += $2; loc += $1 + $2 &#125; \\END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s &quot;, add, subs, loc &#125;&#x27; . “:(exclude)folderName” folderName指src&#x2F;test文件夹，这里是相对路径 . “:(exclude)folderName1” “:(exclude)folderName2” 排除多个文件夹 . “:(exclude)folderName”也 可以用在其他的统计中；–前只能有一个空格，有多个空格识别不了 9.根据指定文件夹统计123git log --since=2021-06-24 --until=2021-06-30 --pretty=tformat: --numstat | grep src/test | gawk &#x27;&#123; add += $1; subs += $2; loc += $1 + $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s &quot;, add, subs, loc &#125;&#x27; src&#x2F;test 指定src的test目录下 注意：增删也算统计的代码量就修改loc +&#x3D; $1 + $2 10.代码存量1find . -name *\\.java -exec wc -l &#123;&#125; \\; | awk &#x27;&#123;s+=$1&#125;END&#123;print s&#125;&#x27; 二、Git常用命令git clone 项目地址克隆一个git项目到本地,将git项目拉取到本地 git status查看文件状态,列出当前目录没有被git管理，以及被修改过还未提交的文件 git add *将我们提交的文件添加到索引库中（添加到缓冲区），*可以是路径也可以是.符号，git add . 代表将当前目录下的所有文件都添加到索引库中,如果指定路径则代表将制定路径的文件添加到索引库中。 git commit -m “备注”将文件推送到本地仓库中,-m 后可以填写此次提交的备注如git commit -m “提交删除功能代码”，那么在git项目中的提交记录里面就能看见你的推送备注。这一步仅仅是放在缓冲区中，还未真正提交代码。 git push origin 分支名这一步才是推送代码推送时需要跟分支名，表示需要将代码推送至某个分支.如git push origin dev表示你要讲代码推送至dev分支。 git pull更新当前分支的代码,获取最新的代码。 git checkout 分支名从当前分支切换至另一个分支。 git merge 分支名当前分支合并其他分支。 git add src&#x2F;XXX提交被忽略的文件，如果抛出如下异常： 123The following paths are ignored by one of your .gitignore files:src/XXXUse -f if you really want to add them. 提示提交的时候，需要加 –f。使用如下命令即可解决： 1git add -f src/XXX","tags":["Git"],"categories":["Git"]},{"title":"09.Mygin之错误恢复Recover中间件","path":"/2022/03/04/09-Mygin之错误恢复Recover中间件.html","content":"本篇是mygin这个系列的最后一篇。如果想自己动手实现一个类似Gin的Web框架，建议从 mgin第一篇开始，总代码行数有效行数只有600多行 github源码 mygin 目的 实现错误处理机制 panic简介在实现错误处理机制之前，我们知道在Go 中，错误的处理方式依靠return返回，由调用者处理。如果是不可恢复的错误，可以手动抛出错误，当然在实际运行中，也会遇到不可处理的错误，比如说除数为0的时候painc 也会触发。终止当前的程序。 手动触发错误123456//main.gofunc main() &#123; fmt.Println(&quot;before ....&quot;) panic(&quot;some err message&quot;) fmt.Println(&quot;after ....&quot;)&#125; shell12345678~ go run cmd/main.gobefore ....panic: some err messagegoroutine 1 [running]:main.main() /var/www/gophp/cmd/main.go:12 +0x5fexit status 2 程序发生错误12345func main() &#123; i := []int&#123;0&#125; j := 2 fmt.Println(j / i[0])&#125; shell1234567go run cmd/main.gopanic: runtime error: integer divide by zerogoroutine 1 [running]:main.main() /var/www/gophp/cmd/main.go:13 +0x194exit status 2 painc 的介绍到此为止，也就是发生了painc 错误，对程序来说就是比较严重的，就会中断，但是这个时候需要捕获到这个painc 错误，Go中没有try…Catch…又想捕获错误，这个时候就该defer 出场了。 defer简介panic会导致程序被中止，但是在程序终止前，会先把当前协程上已经defer的任务，执行完成后再终止。效果类似于其他语言的try…catch。 示例12345678910//cmd/main.gofunc main() &#123; defer func() &#123; fmt.Println(&quot;defer....&quot;) &#125;() i := []int&#123;0&#125; j := 2 fmt.Println(j / i[0])&#125; shell12345678~ go run cmd/main.godefer....panic: runtime error: integer divide by zerogoroutine 1 [running]:main.main() /var/www/gophp/cmd/main.go:16 +0x1d3exit status 2 可以看到，在程序退出之前先执行了defer 中的函数。如果能在defer 中捕获painc 错误，那么就能实现其他语言的try…catch recover函数介绍之前看官方文档怎么定义的 123456789101112131415// The recover built-in function allows a program to manage behavior of a// panicking goroutine. Executing a call to recover inside a deferred// function (but not any function called by it) stops the panicking sequence// by restoring normal execution and retrieves the error value passed to the// call of panic. If recover is called outside the deferred function it will// not stop a panicking sequence. In this case, or when the goroutine is not// panicking, or if the argument supplied to panic was nil, recover returns// nil. Thus the return value from recover reports whether the goroutine is// panicking.翻译后...recover 内置函数允许程序管理恐慌的 goroutine 的行为。在延迟函数（但不是它调用的任何函数）中执行恢复调用会通过恢复正常执行来停止 panic 序列，并检索传递给 panic 调用的错误值。如果在延迟函数之外调用 recover，则不会停止紧急序列。在这种情况下，或者当 goroutine 没有 panic 时，或者如果提供给 panic 的参数为 nil，则 recover 返回 nil。因此，recover 的返回值报告 goroutine 是否处于恐慌状态。 mygin应用 cmd&#x2F;main.go123456789101112func main() &#123; defer func() &#123; fmt.Println(&quot;defer....&quot;) if err := recover(); err != nil &#123; fmt.Printf(&quot;recover 到错误信息：%s &quot;, err.(error).Error()) fmt.Println(&quot;recover success&quot;) &#125; &#125;() i := []int&#123;0&#125; j := 2 fmt.Println(j / i[0]) fmt.Println(&quot;after panic&quot;) shell1234~ go run cmd/main.godefer....recover 到错误信息：runtime error: integer divide by zerorecover success 可以看到已经捕获到错误信息了，程序正常结束。 after panic 没有打印，这是正确的，当panic 被触发时，程序的执行栈就到定义的defer 函数。就像在try代码块中发生了异常，执行栈来到 catch，接下来执行 catch 代码块中的代码。而在 main() 中打印了 recover success，说明程序已经恢复正常，继续往下执行直到结束。 mygin的错误处理对一个 Web 框架而言，错误处理机制是必要的。如果发生了painc错误，应当返回错误信息或告诉对方失败了，而不至于什么都不返回，对调用方十分不友好。例如我有如下的逻辑 123456789101112131415161718192021222324252627package mainimport (\t&quot;fmt&quot;\t&quot;github.com/scott-pb/mygin&quot;\t&quot;net/http&quot;\t&quot;strconv&quot;)func main() &#123;\tr := mygin.Default()\tgroup := r.Group(&quot;/api&quot;)\tgroup.GET(&quot;/recovery/:index&quot;, func(c *mygin.Context) &#123; index := c.Params.ByName(&quot;index&quot;) i, _ := strconv.ParseInt(index, 10, 10) s := []int&#123;1, 3, 5, 7, 9&#125; c.String(http.StatusOK, fmt.Sprintf(&quot;index:%d result:%d success! &quot;, i, s[i]))\t&#125;)\terr := r.Run(&quot;:8088&quot;)\tif err != nil &#123; fmt.Println(err)\t&#125;&#125; 根据调用方传递的index下标函数数组中的值，当传递的index超过数组下标时，就会发生painc错误，如果执行&#x2F;api&#x2F;recovery&#x2F;10 时，就会发生错误。调用方什么返回都没有。这个时候，就需要添加一个错误的处理机制，当错误发生时，向调用方返回Internal Server Error，且打印必要的错误信息，方便进行错误定位。 实现中间件 Recovery新增文件 mygin&#x2F;recovery.go，在这个文件中实现中间件 Recovery mygin&#x2F;recovery.go123456789101112131415161718192021222324package myginimport (\t&quot;fmt&quot;\t&quot;net/http&quot;)// Recovery 发生错误时，恢复函数，且返回相应错误信息。func Recovery() HandlerFunc &#123;\treturn func(c *Context) &#123; // 使用defer延迟执行，以便在函数退出时进行recover defer func() &#123; if err := recover(); err != nil &#123; // 如果发生panic，打印错误信息并返回500 Internal Server Error响应 fmt.Println(err.(error).Error()) c.Writer.Write([]byte(&quot;Internal Server Error &quot;)) c.status = http.StatusInternalServerError c.Abort() // 终止后续中间件的执行 &#125; &#125;() c.Next() // 调用下一个中间件或处理函数\t&#125;&#125; Recovery 方法很简单，使用defer挂载上错误恢复的函数，在这个函数中调用 recover方法，捕获panic，打印错误信息，并且向调用方返回 Internal Server Error。 mygin&#x2F;engine.go123456789101112// Default 返回一个默认的引擎实例func Default() *Engine &#123;\tengine := New() //Logger Recovery 中间件\tengine.Use(Logger(), Recovery())\t// Group 保存 engine 的指针\tengine.RouterGroup.engine = engine\treturn engine&#125; 接下来就是测试了 测试 shell1234~ curl http://127.0.0.1:8088/api/recovery/1index:1 result:3 success!~ curl http://127.0.0.1:8088/api/recovery/10Internal Server Error 控制台输出可以看到第一次请求返回200成功，第二次请求，先打印了错误信息，然后对应的返回500错误，且调用方接收到了Internal Server Error。","tags":["Golang","Web"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"08.Mygin中间件优化及logger日志中间件","path":"/2022/03/02/08-Mygin中间件优化及logger日志中间件.html","content":"本篇是mygin的第八篇，参照gin框架，Mygin从零开始完全手写，在实现的同时，带你一窥gin框架的核心原理实现。 目的 中间件Middleware优化 默认log日志中间件在上篇 Mygin实现中间件Middleware 中间件Middleware很生硬，完全依赖循环，如果某个中间件想要cover住全部中间件，比如我想记录，整个请求的耗时时间，以便针对优化的功能。因此需要把之前生硬的方式做一些修改。 修改1.实例化上下文修改12345678//实例化一个下上文\tc := &amp;Context&#123; Request: r, Writer: w, Params: params, handlers: handlers, index: -1, //默认下标为-1\t&#125; 2.修改上下文Next方法12345678910// Next 执行链中的剩余处理程序。func (c *Context) Next() &#123;\tc.index++\t//遍历handlers\tfor c.index &lt; int8(len(c.handlers)) &#123; //真正调用执行handler方法 c.handlers[c.index](c) c.index++\t&#125;&#125; 日志参照(复制)gin中的写法，新建mygin&#x2F;logger.go日志中间件文件。 mygin&#x2F;logger.go1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package myginimport (\t&quot;fmt&quot;\t&quot;net/http&quot;\t&quot;time&quot;)const (\tgreen = &quot;\\033[97;42m&quot; // 绿色\twhite = &quot;\\033[90;47m&quot; // 白色\tyellow = &quot;\\033[90;43m&quot; // 黄色\tred = &quot;\\033[97;41m&quot; // 红色\tblue = &quot;\\033[97;44m&quot; // 蓝色\tmagenta = &quot;\\033[97;45m&quot; // 洋红色\tcyan = &quot;\\033[97;46m&quot; // 青色\treset = &quot;\\033[0m&quot; // 重置颜色)type LogFormatterParams struct &#123;&#125;// MethodColor 方法颜色获取func (l *LogFormatterParams) MethodColor(method string) string &#123;\tswitch method &#123;\tcase http.MethodGet: return blue\tcase http.MethodPost: return cyan\tcase http.MethodPut: return yellow\tcase http.MethodDelete: return red\tcase http.MethodPatch: return green\tcase http.MethodHead: return magenta\tcase http.MethodOptions: return white\tdefault: return reset\t&#125;&#125;// StatusCodeColor 状态颜色获取func (l *LogFormatterParams) StatusCodeColor(code int) string &#123;\tswitch &#123;\tcase code &gt;= http.StatusOK &amp;&amp; code &lt; http.StatusMultipleChoices: return green\tcase code &gt;= http.StatusMultipleChoices &amp;&amp; code &lt; http.StatusBadRequest: return white\tcase code &gt;= http.StatusBadRequest &amp;&amp; code &lt; http.StatusInternalServerError: return yellow\tdefault: return red\t&#125;&#125;// LoggerFunc 记录日志的方法func (l *LogFormatterParams) LoggerFunc() HandlerFunc &#123;\treturn func(context *Context) &#123; // 启动时间 start := time.Now() // 后续处理请求 context.Next() //后续处理请求 结束时间 now := time.Now() str := fmt.Sprintf(&quot;[MyGIN] %v |%s %3d %s| %13v |%s %-7s %s %#v &quot;, now.Format(&quot;2006/01/02 - 15:04:05&quot;), l.StatusCodeColor(context.status), context.status, reset, now.Sub(start), //耗时 l.MethodColor(context.Request.Method), context.Request.Method, reset, context.Request.URL.Path, ) fmt.Println(str)\t&#125;&#125; 日志中间件 测试测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041package myginimport (\t&quot;net/http&quot;\t&quot;path&quot;\t&quot;testing&quot;)func TestMyGin06(t *testing.T) &#123;\tr := Default()\tr.Use()\t//测试需要登录\tgroup := r.Group(&quot;/api&quot;, func(context *Context) &#123; //todo.... context.String(http.StatusOK, &quot;api Group 中间件失败了.... &quot;) context.Abort()\t&#125;)\tgroup.Use()\t//这个回调不会执行\tgroup.GET(&quot;/hello/:name&quot;, func(context *Context) &#123; name := context.Params.ByName(&quot;name&quot;) context.String(http.StatusOK, path.Join(&quot;hello &quot;, name, &quot;!&quot;))\t&#125;)\t//测试没有发生Abort\tgroup2 := r.Group(&quot;/api2&quot;, func(context *Context) &#123; //todo.... context.String(http.StatusOK, &quot;api Group 中间件成功了.... &quot;)\t&#125;)\t//这个回调会执行\tgroup2.GET(&quot;/hello2/:name&quot;, func(context *Context) &#123; name := context.Params.ByName(&quot;name&quot;) context.String(http.StatusOK, path.Join(&quot;hello2 &quot;, name, &quot;! &quot;))\t&#125;)\t// 启动服务器并监听端口\tr.Run(&quot;:8088&quot;)&#125; 启动测试1go test curl请求测试123456789101112131415curl -i http://localhost:8088/api2/hello2/scottHTTP/1.1 200 OKContent-Type: text/plain; charset=utf-8Date: Tue, 30 Jan 2024 06:56:03 GMTContent-Length: 49api Group 中间件成功了....hello2 /scott/!➜ ~ curl -i http://localhost:8088/api/hello/scottHTTP/1.1 200 OKContent-Type: text/plain; charset=utf-8Date: Tue, 30 Jan 2024 06:56:26 GMTContent-Length: 33api Group 中间件失败了.... 查看控制台输出","tags":["Golang","Web"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"07.Mygin中sync.Pool应用","path":"/2022/02/11/mygin-day07.html","content":"本篇是mygin的第六篇，参照gin框架，感兴趣的可以从 Mygin第一篇 开始看，Mygin从零开始完全手写，在实现的同时，带你一窥gin框架的核心原理实现。 目的 sync.Pool 的作用介绍 mygin中使用sync.Pool sync.Pool 的作用先看看官方文档怎样说的吧，我截取了官方文档的第一句。 12// A Pool is a set of temporary objects that may be individually saved and retrieved...... 简单翻译一下的意思是:池是一组可以单独保存和检索的临时对象。既然可以单独保存和检索的临时对象，对于大量重复地创建许多对象，造成 GC 的工作量巨大。而mygin的模式是 责任链模式 ,因此满足使用 sync.Pool。 一个 Pool 可以安全地由多个 goroutine 同时使用。池的目的是缓存已分配但未使用的项目以供以后重用，从而减轻垃圾回收器的压力。 sync.Pool 是可伸缩的，同时也是并发安全的，其大小仅受限于内存的大小。sync.Pool 用于存储那些被分配了但是没有被使用，而未来可能会使用的值。这样就可以不用再次经过内存分配，可直接复用已有对象，减轻 GC 的压力，从而提升系统的性能。以上都是源于官方文档翻译的，文档中还提到fmt包中，打印也使用了sync.Pool,感兴趣的可以点进源码查看。 sync.Pool 使用sync.Pool 的使用方式非常简单：只需要实现New函数即可。对象池中没有对象时，将会调用New函数创建,我使用了mygin中的context 创建12345var contextPool = sync.Pool&#123;\tNew: func() interface&#123;&#125; &#123; return new(Context)\t&#125;,&#125; 使用和归还123c := contextPool.Get().(*Context)json.Marshal(c)contextPool.Put(c) 测试123456789101112131415func BenchmarkUnmarshal(b *testing.B) &#123;\tfor n := 0; n &lt; b.N; n++ &#123; c := &amp;Context&#123;&#125; json.Marshal(c)\t&#125;&#125;func BenchmarkUnmarshalWithPool(b *testing.B) &#123;\tfor n := 0; n &lt; b.N; n++ &#123; c := contextPool.Get().(*Context) json.Marshal(c) contextPool.Put(c)\t&#125;&#125; 测试结果:123456789go test -bench . -benchmemgoos: linuxgoarch: amd64pkg: github.com/scott-pb/mygincpu: 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHzBenchmarkUnmarshal-8 5888780 208.1 ns/op 144 B/op 2 allocs/opBenchmarkUnmarshalWithPool-8 7261801 165.0 ns/op 48 B/op 1 allocs/opPASSok github.com/scott-pb/mygin 2.808s 在这个例子中，可以看出，使用了 sync.Pool 后，内存占用仅为未使用的 48&#x2F;144&#x3D; 1&#x2F;3，对 GC 的影响就很大了。执行速度也快了，当然不同的设备测试结果也会不同。 测试源码我把测试源码放在了mygin中 mygin&#x2F;context_test.go mygin使用sync.Pool修改mygin&#x2F;engine.go修改engine.go中实例化conetxt的部分具体在ServeHTTP 方法中 修改前12345678//实例化一个下上文c := &amp;Context&#123;\tRequest: r,\tWriter: w,\tParams: params,\thandlers: handlers,\tindex: -1,&#125; 修改后12345678910111213//从pool中取c := e.pool.Get().(*Context)c.Request = rc.Writer = wc.Params = paramsc.handlers = handlersc.index = -1// 执行处理函数链c.Next()//归还到pool中e.pool.Put(c) mygin测试main方法代码如下 123456789101112131415161718192021package mainimport (\t&quot;fmt&quot;\t&quot;github.com/scott-pb/mygin&quot;\t&quot;net/http&quot;)func main() &#123;\tr := mygin.Default()\tgroup := r.Group(&quot;/api&quot;)\tgroup.GET(&quot;/test&quot;, func(c *mygin.Context) &#123; c.String(http.StatusOK, &quot;success! &quot;)\t&#125;)\terr := r.Run(&quot;:8088&quot;)\tif err != nil &#123; fmt.Println(err)\t&#125;&#125; curl测试1234567curl -i http://localhost:8088/api/testHTTP/1.1 200 OKContent-Type: text/plain; charset=utf-8Date: Thu, 01 Feb 2024 05:08:52 GMTContent-Length: 9success! 这样mygin的context上下文就加入了Pool池，对于高并发情况下的GC压力会减轻不少。我设计的上下文中内容很少，随着功能的增多，效果会更加明显。","tags":["Golang","Web"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"06.Mygin实现中间件Middleware","path":"/2022/02/07/mygin-day06.html","content":"本篇是mygin的第六篇，参照gin框架，感兴趣的可以从 Mygin第一篇 开始看，Mygin从零开始完全手写，在实现的同时，带你一窥gin框架的核心原理实现。 目的 实现中间件Middleware在上一篇 Mygin实现分组路由Group 中，实现了路由分组，且同一分组的执行，会先执行Group，有一点点中间件的雏形了。但是中间件不完全还应该提供中断功能，比如一个Group组中添加了auth鉴权中间件，只有auth认证通过才可以通过，因此需要对上篇中的内容进行一些修改。在实现之前，先分析gin中是怎样去实现的这一功能的123456789func (c *Context) Next() &#123;\tc.index++ //遍历handlers\tfor c.index &lt; int8(len(c.handlers)) &#123; //真正调用执行handler方法 c.handlers[c.index](c) c.index++\t&#125;&#125; 这个时候就有疑问了，从上述方法中看不到中间件执行失败的中断方法，那又是怎么实现中断。在揭晓答案之前，先看看int8(len(c.handlers) 为什么要写个int8，原因在于gin中规定的handlers最多63个，相信实际的应用请求中，没有超过63个那么多变态的执行链。在gin中如果某一中间件执行失败，就把c.index赋值为63，上述for循环就不满足条件，因此就跳出for循环，不再继续执行后面的代码。gin中对应的代码也很简单。12345const abortIndex int8 = math.MaxInt8 &gt;&gt; 1//中间件执行失败，中断方法func (c *Context) Abort() &#123;\tc.index = abortIndex&#125; 因此只需在mygin&#x2F;content.go中新加Next方法和Abort方法 上下文content.go中的代码不多，索性加上注释全部贴出来。 mygin&#x2F;content.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package myginimport (\t&quot;encoding/json&quot;\t&quot;math&quot;\t&quot;net/http&quot;)// 定义 表示最大和上下文应中止时的索引值const abortIndex int8 = math.MaxInt8 &gt;&gt; 1// Context 封装了一个HTTP请求的上下文type Context struct &#123;\tRequest *http.Request\tWriter http.ResponseWriter\tParams Params\tindex int8&#125;// Next 执行链中的剩余处理程序。func (c *Context) Next(handlers HandlersChain) &#123;\t//遍历handlers\tfor c.index &lt; int8(len(handlers)) &#123; //真正调用执行handler方法 handlers[c.index](c) c.index++\t&#125;&#125;// Abort 中断链中剩余处理程序的执行。func (c *Context) Abort() &#123;\tc.index = abortIndex&#125;// IsAborted 如果当前上下文被中止，则返回true。func (c *Context) IsAborted() bool &#123;\treturn c.index &gt;= abortIndex&#125;// writeContentType 如果尚未设置，则设置Content-Type标头。func writeContentType(w http.ResponseWriter, value []string) &#123;\theader := w.Header()\tif val := header[&quot;Content-Type&quot;]; len(val) == 0 &#123; header[&quot;Content-Type&quot;] = value\t&#125;&#125;// Status 设置HTTP响应状态码。func (c *Context) Status(code int) &#123;\tc.Writer.WriteHeader(code)&#125;// JSON 将值序列化为JSON并将其写入响应。func (c *Context) JSON(v interface&#123;&#125;) error &#123;\twriteContentType(c.Writer, []string&#123;&quot;application/json; charset=utf-8&quot;&#125;)\tencoder := json.NewEncoder(c.Writer)\terr := encoder.Encode(v)\tif err != nil &#123; c.Status(http.StatusInternalServerError)\t&#125;\tc.Status(http.StatusOK)\treturn err&#125;// Html 将字符串以HTML形式写入响应。func (c *Context) Html(v string) error &#123;\twriteContentType(c.Writer, []string&#123;&quot;text/html; charset=utf-8&quot;&#125;)\tc.Status(http.StatusOK)\t_, err := c.Writer.Write([]byte(v))\treturn err&#125;// String 将字符串写入响应func (c *Context) String(v string) error &#123;\twriteContentType(c.Writer, []string&#123;&quot;text/plain; charset=utf-8&quot;&#125;)\tc.Status(http.StatusOK)\t_, err := c.Writer.Write([]byte(v))\treturn err&#125; 接下来就是调用handles的修改了，原来的解决方法是直接循环调用，对应的代码如下:1234567for _, handler := range handlers &#123; handler(&amp;Context&#123; Request: r, Writer: w, Params: params, &#125;)\t&#125; 引擎 mygin&#x2F;engine.go现在找到engine.go文件中将上面的代码替换为:12345678//实例化一个下上文c := &amp;Context&#123;\tRequest: r,\tWriter: w,\tParams: params,&#125;// 执行处理函数链c.Next(handlers) 测试代码1234567891011121314151617181920212223242526272829303132333435363738package mainimport (\t&quot;gophp/mygin&quot;\t&quot;path&quot;)func main() &#123;\t// 创建一个默认的 mygin 实例\tr := mygin.Default()\t//测试Abort\tgroup := r.Group(&quot;/api&quot;, func(context *mygin.Context) &#123; //todo.... context.String(&quot;api Group 中间件失败了.... &quot;) context.Abort()\t&#125;)\t//这个回调不会执行\tgroup.GET(&quot;/hello/:name&quot;, func(context *mygin.Context) &#123; name := context.Params.ByName(&quot;name&quot;) context.String(path.Join(&quot;hello &quot;, name, &quot;!&quot;))\t&#125;)\t//测试没有发生Abort\tgroup2 := r.Group(&quot;/api2&quot;, func(context *mygin.Context) &#123; //todo.... context.String(&quot;api Group 中间件成功了.... &quot;)\t&#125;) //这个回调会执行\tgroup2.GET(&quot;/hello2/:name&quot;, func(context *mygin.Context) &#123; name := context.Params.ByName(&quot;name&quot;) context.String(path.Join(&quot;hello2 &quot;, name, &quot;! &quot;))\t&#125;)\t// 启动服务器并监听端口\tr.Run(&quot;:8088&quot;)&#125; curl测试12345 curl http://127.0.0.1:8088/api/hello/scottapi Group 中间件失败了....~ curl http://127.0.0.1:8088/api2/hello2/scottapi Group 中间件成功了....hello2 /scott/! 看到上诉输出，即为成功。赶快去试试吧！","tags":["Golang","Web"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"05.Mygin实现分组路由Group","path":"/2022/01/31/mygin-day05.html","content":"本篇是Mygin第五篇 目的 实现路由分组 为什么要分组分组控制(Group Control)是 Web 框架应该提供的基础功能之一，对同一模块功能的开发，应该有相同的前缀。或者对一部分第三方接口，统一需要加解密等功能。分组后很方便。例如： 对于任务模块，统一前缀为&#x2F;task 除去&#x2F;user&#x2F;login接口，都需要鉴权 以&#x2F;openapi 开头的接口，需要对接第三方平台，需要三方平台鉴权 大多数分组都是统一前缀，正确的分组可以实现子分组，无限极往下分组，当然实际情况下也不会有太多层分组。每个分组有不同的中间件(middleware），分组与子分组就像洋葱一样，一层一层往内。要想往内，需要拨开最外层，也就是要执行外层的中间件才能往内。对于分组，也有后续扩展的好处，比如&#x2F;task分组，现在要统一加上访问日志记录，有了分组后就可以在该分组上添加一个中间件就可以了。 分组嵌套在实现分组嵌套之前，先看看gin中的分组嵌套是怎么实现的。gin中的分组中含有Engin的指针，其实很好理解，因为分组要有访问Router的能力。Engin中继承了RouterGroup，实例化Engin后就可以使用Group的功能。有了Engin的指针，整个框架的所有资源都是由Engine去统一调度的，因此通过Engine可以间接地拥有整个框架的功能。你中有我我中有你。 gin&#x2F;routergroup.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package myginimport (\t&quot;net/http&quot;\t&quot;path&quot;\t&quot;regexp&quot;)// IRoutes 定义了路由组的接口type IRoutes interface &#123;\tBasePath() string\tGET(string, ...HandlerFunc) IRoutes\tPOST(string, ...HandlerFunc) IRoutes\tDELETE(string, ...HandlerFunc) IRoutes\tPATCH(string, ...HandlerFunc) IRoutes\tPUT(string, ...HandlerFunc) IRoutes\tOPTIONS(string, ...HandlerFunc) IRoutes\tHEAD(string, ...HandlerFunc) IRoutes\tMatch([]string, string, ...HandlerFunc) IRoutes&#125;// anyMethods 包含所有 HTTP 方法的字符串表示var anyMethods = []string&#123;\thttp.MethodGet, http.MethodPost, http.MethodPut, http.MethodPatch,\thttp.MethodHead, http.MethodOptions, http.MethodDelete, http.MethodConnect,\thttp.MethodTrace,&#125;// RouterGroup 定义了路由组的结构体type RouterGroup struct &#123;\tHandlers HandlersChain // 路由组的中间件处理函数链\tbasePath string // 路由组的基础路径\tengine *Engine // 路由组所属的引擎\troot bool // 是否是根路由组&#125;// Group 创建一个新的路由组func (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup &#123;\treturn &amp;RouterGroup&#123; Handlers: append(group.Handlers, handlers...), basePath: path.Join(group.basePath, relativePath), engine: group.engine,\t&#125;&#125;// BasePath 返回路由组的基础路径func (group *RouterGroup) BasePath() string &#123;\treturn group.basePath&#125;// handle 处理路由，将路由信息添加到引擎中func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes &#123;\tabsolutePath := path.Join(group.basePath, relativePath) //处理函数，Group组定义的函数先执行，自定义的函数后执行\thandlers = append(group.Handlers, handlers...)\tgroup.engine.addRoute(httpMethod, absolutePath, handlers)\tif group.root &#123; return group.engine\t&#125;\treturn group&#125;// Handle 校验 HTTP 方法的有效性，并处理路由func (group *RouterGroup) Handle(httpMethod, relativePath string, handlers ...HandlerFunc) IRoutes &#123;\t// 检查 HTTP 方法的有效性\tif match := regexp.MustCompile(&quot;^[A-Z]+$&quot;).MatchString(httpMethod); !match &#123; panic(&quot;http method &quot; + httpMethod + &quot; is not valid&quot;)\t&#125;\t// 处理路由\treturn group.handle(httpMethod, relativePath, handlers)&#125;// GET 注册 GET 方法的路由func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes &#123;\treturn group.handle(http.MethodGet, relativePath, handlers)&#125;// POST 注册 POST 方法的路由func (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes &#123;\treturn group.handle(http.MethodPost, relativePath, handlers)&#125;// DELETE 注册 DELETE 方法的路由func (group *RouterGroup) DELETE(relativePath string, handlers ...HandlerFunc) IRoutes &#123;\treturn group.handle(http.MethodDelete, relativePath, handlers)&#125;// PATCH 注册 PATCH 方法的路由func (group *RouterGroup) PATCH(relativePath string, handlers ...HandlerFunc) IRoutes &#123;\treturn group.handle(http.MethodPatch, relativePath, handlers)&#125;// PUT 注册 PUT 方法的路由func (group *RouterGroup) PUT(relativePath string, handlers ...HandlerFunc) IRoutes &#123;\treturn group.handle(http.MethodPut, relativePath, handlers)&#125;// OPTIONS 注册 OPTIONS 方法的路由func (group *RouterGroup) OPTIONS(relativePath string, handlers ...HandlerFunc) IRoutes &#123;\treturn group.handle(http.MethodOptions, relativePath, handlers)&#125;// HEAD 注册 HEAD 方法的路由func (group *RouterGroup) HEAD(relativePath string, handlers ...HandlerFunc) IRoutes &#123;\treturn group.handle(http.MethodHead, relativePath, handlers)&#125;// Match 注册多个方法的路由func (group *RouterGroup) Match(methods []string, relativePath string, handlers ...HandlerFunc) IRoutes &#123;\tfor _, method := range methods &#123; group.handle(method, relativePath, handlers)\t&#125;\tif group.root &#123; return group.engine\t&#125;\treturn group&#125;// Any 注册所有方法的路由func (group *RouterGroup) Any(relativePath string, handlers ...HandlerFunc) IRoutes &#123;\tfor _, method := range anyMethods &#123; group.handle(method, relativePath, handlers)\t&#125;\tif group.root &#123; return group.engine\t&#125;\treturn group&#125; 可以看到group.engine.addRoute方法，实际调用的仍然是mygin&#x2F;router.go中的addRoute方法。当group.root为true，也就是为根时，相当于没有调用Group方法，返回group.engine，也就是相当于直接调用的engine，只有当调用Group方法后才会返回group。接下来看engine的修改 mygin&#x2F;engine.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package myginimport (\t&quot;net/http&quot;)// HandlerFunc 定义处理函数类型type HandlerFunc func(*Context)// HandlersChain 定义处理函数链类型type HandlersChain []HandlerFunc// Engine 定义引擎结构，包含路由器type Engine struct &#123;\tRouter\tRouterGroup&#125;// ServeHTTP 实现http.Handler接口的方法，用于处理HTTP请求func (e *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;\t// 获取对应HTTP方法的路由树的根节点\troot := e.trees.get(r.Method)\t// 解析请求路径\tparts := root.parseFullPath(r.URL.Path)\t// 查找符合条件的节点\tsearchNode := make([]*node, 0)\troot.search(parts, &amp;searchNode)\t// 没有匹配到路由\tif len(searchNode) == 0 &#123; w.Write([]byte(&quot;404 Not found! &quot;)) return\t&#125;\t// 参数赋值\tparams := make([]Param, 0)\tsearchPath := root.parseFullPath(searchNode[0].fullPath)\tfor i, sp := range searchPath &#123; if sp[0] == &#x27;:&#x27; &#123; params = append(params, Param&#123; Key: sp[1:], Value: parts[i], &#125;) &#125;\t&#125;\t// 获取处理函数链\thandlers := searchNode[0].handlers\tif handlers == nil &#123; w.Write([]byte(&quot;404 Not found! &quot;)) return\t&#125;\t// 执行处理函数链\tfor _, handler := range handlers &#123; handler(&amp;Context&#123; Request: r, Writer: w, Params: params, &#125;)\t&#125;&#125;// Default 返回一个默认的引擎实例func Default() *Engine &#123;\tengine := &amp;Engine&#123; Router: Router&#123; trees: make(methodTrees, 0, 9), &#125;, RouterGroup: RouterGroup&#123; Handlers: nil, basePath: &quot;/&quot;, root: true, &#125;,\t&#125;\t// Group 保存 engine 的指针\tengine.RouterGroup.engine = engine\treturn engine&#125;// Run 启动HTTP服务器的方法func (e *Engine) Run(addr string) error &#123;\treturn http.ListenAndServe(addr, e)&#125; 可以仔细观察下addRoute函数，调用了group.engine.router.addRoute来实现了路由的映射。由于Engine从某种意义上继承了RouterGroup的所有属性和方法，因为 (*Engine).engine 是指向自己的。这样实现，我们既可以像原来一样添加路由，也可以通过分组添加路由。 最后来测试一下 main.go12345678910111213141516171819202122232425262728package mainimport (\t&quot;gophp/mygin&quot;\t&quot;path&quot;)func main() &#123;\t// 创建一个默认的 mygin 实例\tr := mygin.Default()\tgroup := r.Group(&quot;/api&quot;, func(context *mygin.Context) &#123; context.String(&quot;api Group .... &quot;)\t&#125;)\tgroup.GET(&quot;/hello/:name&quot;, func(context *mygin.Context) &#123; name := context.Params.ByName(&quot;name&quot;) context.String(path.Join(&quot;hello &quot;, name, &quot;!&quot;))\t&#125;)\tgroup.GET(&quot;/hello2/:name&quot;, func(context *mygin.Context) &#123; name := context.Params.ByName(&quot;name&quot;) context.String(path.Join(&quot;hello2 &quot;, name, &quot;! &quot;))\t&#125;)\t// 启动服务器并监听端口\tr.Run(&quot;:8088&quot;)&#125; curl请求测试12345678910111213141516 curl -i http://localhost:8088/api/hello/scottHTTP/1.1 200 OKContent-Type: text/plain; charset=utf-8Date: Wed, 24 Jan 2024 05:16:45 GMTContent-Length: 29api Group ....hello /scott/!~ curl -i http://localhost:8088/api/hello2/scottHTTP/1.1 200 OKContent-Type: text/plain; charset=utf-8Date: Wed, 24 Jan 2024 05:16:54 GMTContent-Length: 31api Group ....hello2 /scott/! 可以看到两个路由都安装预定的返回了，即先返回Group定义的，再返回路由定义的。","tags":["Golang","Web"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"04.Mygin实现动态路由","path":"/2022/01/30/mygin-day04.html","content":"本篇是Mygin的第四篇 目的 使用 Trie 树实现动态路由解析。 参数绑定 前缀树本篇比前几篇要复杂一点，原来的路由是用map实现，索引非常高效，但是有一个弊端，键值对的存储的方式，只能用来索引静态路由。遇到类似hello&#x2F;:name这动态路由就无能为力了，实现动态路由最常用的数据结构，被称为前缀树。这种结构非常适用于路由匹配。比如我们定义了如下路由： &#x2F;a&#x2F;b&#x2F;c &#x2F;a&#x2F;b &#x2F;a&#x2F;c &#x2F;a&#x2F;b&#x2F;c&#x2F;d &#x2F;a&#x2F;:name&#x2F;c &#x2F;a&#x2F;:name&#x2F;c&#x2F;d &#x2F;a&#x2F;b&#x2F;:name&#x2F;e 在前缀树中的结构体 HTTP请求的路径是由&#x2F;分隔的字符串构成的,所以用&#x2F;拆分URL字符串，得到不同的树节点，且有对应的层级关系。 代码实现 Mygin&#x2F;tree.go 首先看tree中node结构定义12345678type node struct &#123;\tchildren []*node //子节点\tpart string //树节点\twildChild bool //是否是精确匹配\thandlers HandlersChain //路由回调，实际的请求\tnType nodeType //节点类型 默认static params\tfullPath string //完整路径&#125; 与普通的树不同，为了实现动态路由匹配，加上了wildChild这个参数。即当我们匹配 &#x2F;a&#x2F;scott&#x2F;c这个路由时，第一层节点，a精准匹配到了b，第二层节点，b模糊匹配到:name，那么将会把name这个参数赋值为scott，继续下一层匹配。我们将匹配的逻辑，包装为一个辅助函数。 Mygin&#x2F;tree.go 具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178package myginimport (\t&quot;strings&quot;)type nodeType uint8// 路由的类型const (\tstatic nodeType = iota\troot\tparam\tcatchAll)// 不同的method 对应不同的节点树 定义type methodTree struct &#123;\tmethod string\troot *node&#125;// Param 参数的类型key=&gt; valuetype Param struct &#123;\tKey string\tValue string&#125;// Params 切片type Params []Paramtype methodTrees []methodTreetype node struct &#123;\tchildren []*node\tpart string\twildChild bool\thandlers HandlersChain\tnType nodeType\tfullPath string&#125;// Get 获取 参数中的值func (ps Params) Get(name string) (string, bool) &#123;\tfor _, entry := range ps &#123; if entry.Key == name &#123; return entry.Value, true &#125;\t&#125;\treturn &quot;&quot;, false&#125;// ByName 通过ByName获取参数中的值 会忽略掉错误，默认返回 空字符串func (ps Params) ByName(name string) (v string) &#123;\tv, _ = ps.Get(name)\treturn&#125;// 根据method获取rootfunc (trees methodTrees) get(method string) *node &#123;\tfor _, tree := range trees &#123; if tree.method == method &#123; return tree.root &#125;\t&#125;\treturn nil&#125;// 添加路径时func (n *node) addRoute(path string, handlers HandlersChain) &#123;\t//根据请求路径按照&#x27;/&#x27;划分\tparts := n.parseFullPath(path)\t//将节点插入路由后，返回最后一个节点\tmatchNode := n.insert(parts)\t//最后的节点，绑定执行链\tmatchNode.handlers = handlers\t//最后的节点，绑定完全的URL，后续param时有用\tmatchNode.fullPath = path&#125;// 按照 &quot;/&quot; 拆分字符串func (n *node) parseFullPath(fullPath string) []string &#123;\tsplits := strings.Split(fullPath, &quot;/&quot;)\tparts := make([]string, 0)\tfor _, part := range splits &#123; if part != &quot;&quot; &#123; parts = append(parts, part) if part == &quot;*&quot; &#123; break &#125; &#125;\t&#125;\treturn parts&#125;// 根据路径 生成节点树func (n *node) insert(parts []string) *node &#123;\tpart := parts[0]\t//默认的字节类型为静态类型\tnt := static\t//根据前缀判断节点类型\tswitch part[0] &#123;\tcase &#x27;:&#x27;: nt = param\tcase &#x27;*&#x27;: nt = catchAll\t&#125;\t//插入的节点查找\tvar matchNode *node\tfor _, childNode := range n.children &#123; if childNode.part == part &#123; matchNode = childNode &#125;\t&#125;\t//如果即将插入的节点没有找到，则新建一个\tif matchNode == nil &#123; matchNode = &amp;node&#123; part: part, wildChild: part[0] == &#x27;*&#x27; || part[0] == &#x27;:&#x27;, nType: nt, &#125; //新子节点追加到当前的子节点中 n.children = append(n.children, matchNode)\t&#125;\t//当最后插入的节点时，类型赋值，且返回最后的节点\tif len(parts) == 1 &#123; matchNode.nType = nt return matchNode\t&#125;\t//匹配下一部分\tparts = parts[1:]\t//子节点继续插入剩余字部分\treturn matchNode.insert(parts)&#125;// 根据路由 查询符合条件的节点func (n *node) search(parts []string, searchNode *[]*node) &#123;\tpart := parts[0] //a\tallChild := n.matchChild(part) //b c :name\tif len(parts) == 1 &#123; // 如果到达路径末尾，将所有匹配的节点加入结果 *searchNode = append(*searchNode, allChild...) return\t&#125;\tparts = parts[1:] //b\tfor _, n2 := range allChild &#123; // 递归查找下一部分 n2.search(parts, searchNode)\t&#125;&#125;// 根据part 返回匹配成功的子节点func (n *node) matchChild(part string) []*node &#123;\tallChild := make([]*node, 0)\tfor _, child := range n.children &#123; if child.wildChild || child.part == part &#123; allChild = append(allChild, child) &#125;\t&#125;\treturn allChild&#125; 上诉路由中，实现了插入insert和匹配search时的功能，插入时安装拆分后的子节点，递归查找每一层的节点，如果没有匹配到当前part的节点，则新建一个。查询功能，同样也是递归查询每一层的节点。 Mygin&#x2F;router.go 12345678910111213141516171819202122232425262728293031323334353637package myginimport (\t&quot;net/http&quot;)type Router struct &#123;\ttrees methodTrees&#125;// 添加路由方法func (r *Router) addRoute(method, path string, handlers HandlersChain) &#123;\t//根据method获取root\trootTree := r.trees.get(method)\t//如果root为空\tif rootTree == nil &#123; //初始化一个root rootTree = &amp;node&#123;part: &quot;/&quot;, nType: root&#125; //将初始化后的root 加入tree树中 r.trees = append(r.trees, methodTree&#123;method: method, root: rootTree&#125;)\t&#125;\trootTree.addRoute(path, handlers)&#125;// Get Get方法func (r *Router) Get(path string, handlers ...HandlerFunc) &#123;\tr.addRoute(http.MethodGet, path, handlers)&#125;// Post Post方法func (e *Engine) Post(path string, handlers ...HandlerFunc) &#123;\te.addRoute(http.MethodPost, path, handlers)&#125; router中修改不大 Mygin&#x2F;engine.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package myginimport (\t&quot;net/http&quot;)// HandlerFunc 定义处理函数类型type HandlerFunc func(*Context)// HandlersChain 定义处理函数链类型type HandlersChain []HandlerFunc// Engine 定义引擎结构，包含路由器type Engine struct &#123;\tRouter&#125;// ServeHTTP 实现http.Handler接口的方法，用于处理HTTP请求func (e *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;\t// 获取对应HTTP方法的路由树的根节点\troot := e.trees.get(r.Method)\t// 解析请求路径\tparts := root.parseFullPath(r.URL.Path)\t// 查找符合条件的节点\tsearchNode := make([]*node, 0)\troot.search(parts, &amp;searchNode)\t// 没有匹配到路由\tif len(searchNode) == 0 &#123; w.Write([]byte(&quot;404 Not found! &quot;)) return\t&#125;\t// 参数赋值\tparams := make([]Param, 0)\tsearchPath := root.parseFullPath(searchNode[0].fullPath)\tfor i, sp := range searchPath &#123; if sp[0] == &#x27;:&#x27; &#123; params = append(params, Param&#123; Key: sp[1:], Value: parts[i], &#125;) &#125;\t&#125;\t// 获取处理函数链\thandlers := searchNode[0].handlers\tif handlers == nil &#123; w.Write([]byte(&quot;404 Not found! &quot;)) return\t&#125;\t// 执行处理函数链\tfor _, handler := range handlers &#123; handler(&amp;Context&#123; Request: r, Writer: w, Params: params, &#125;)\t&#125;&#125;// Default 返回一个默认的引擎实例func Default() *Engine &#123;\treturn &amp;Engine&#123; Router: Router&#123; trees: make(methodTrees, 0, 9), &#125;,\t&#125;&#125;// Run 启动HTTP服务器的方法func (e *Engine) Run(addr string) error &#123;\treturn http.ListenAndServe(addr, e)&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport (\t&quot;gophp/mygin&quot;)func main() &#123;\t// 创建一个默认的 mygin 实例\tr := mygin.Default()\t// 定义路由处理函数\thandleABC := func(context *mygin.Context) &#123; context.JSON(map[string]interface&#123;&#125;&#123; &quot;path&quot;: context.Request.URL.Path, &#125;)\t&#125;\t// 注册路由\tr.Get(&quot;/a/b/c&quot;, handleABC)\tr.Get(&quot;/a/b&quot;, handleABC)\tr.Get(&quot;/a/c&quot;, handleABC)\t// 注册带参数的路由\tr.Get(&quot;/a/:name/c&quot;, func(context *mygin.Context) &#123; name := context.Params.ByName(&quot;name&quot;) path := &quot;/a/&quot; + name + &quot;/c&quot; context.JSON(map[string]interface&#123;&#125;&#123; &quot;path&quot;: path, &#125;)\t&#125;)\tr.Get(&quot;/a/:name/c/d&quot;, func(context *mygin.Context) &#123; name := context.Params.ByName(&quot;name&quot;) path := &quot;/a/&quot; + name + &quot;/c/d&quot; context.JSON(map[string]interface&#123;&#125;&#123; &quot;path&quot;: path, &#125;)\t&#125;)\tr.Get(&quot;/a/b/:name/e&quot;, func(context *mygin.Context) &#123; name := context.Params.ByName(&quot;name&quot;) path := &quot;/a/b&quot; + name + &quot;/e&quot; context.JSON(map[string]interface&#123;&#125;&#123; &quot;path&quot;: path, &#125;)\t&#125;)\tr.Get(&quot;/a/b/c/d&quot;, handleABC)\t// 启动服务器并监听端口\tr.Run(&quot;:8088&quot;)&#125; 测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950curl -i http://localhost:8088/a/b/cHTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Tue, 23 Jan 2024 05:43:50 GMTContent-Length: 18&#123;&quot;path&quot;:&quot;/a/b/c&quot;&#125;➜ ~ curl -i http://localhost:8088/a/bHTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Tue, 23 Jan 2024 05:43:53 GMTContent-Length: 16&#123;&quot;path&quot;:&quot;/a/b&quot;&#125;➜ ~ curl -i http://localhost:8088/a/cHTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Tue, 23 Jan 2024 05:43:57 GMTContent-Length: 16&#123;&quot;path&quot;:&quot;/a/c&quot;&#125;➜ ~ curl -i http://localhost:8088/a/b/c/dHTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Tue, 23 Jan 2024 05:44:05 GMTContent-Length: 20&#123;&quot;path&quot;:&quot;/a/b/c/d&quot;&#125;➜ ~ curl -i http://localhost:8088/a/scott/cHTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Tue, 23 Jan 2024 05:45:16 GMTContent-Length: 22&#123;&quot;path&quot;:&quot;/a/scott/c&quot;&#125;➜ ~ curl -i http://localhost:8088/a/scott/c/dHTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Tue, 23 Jan 2024 05:45:22 GMTContent-Length: 24&#123;&quot;path&quot;:&quot;/a/scott/c/d&quot;&#125;➜ ~ curl -i http://localhost:8088/a/b/scott/eHTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Tue, 23 Jan 2024 05:45:32 GMTContent-Length: 23&#123;&quot;path&quot;:&quot;/a/bscott/e&quot;&#125;","tags":["Golang","Web"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"03.Mygin实现上下文","path":"/2022/01/28/mygin-day03.html","content":"本篇是Mygin的第三篇 目的 将路由独立出来，方便后续扩展修改 上下文Context，对http.ResponseWriter和http.Request进行封装，实现对JSON、HTML等的支持 路由新建一个router文件，将 Mygin实现简单的路由 中将路由部分复制出来 新建Mygin&#x2F;router.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package myginimport (\t&quot;log&quot;\t&quot;net/http&quot;)// 路由节点type methodTree struct &#123;\tmethod string\tpaths map[string]func(c *Context)&#125;type methodTrees map[string]methodTreetype Router struct &#123;\ttrees methodTrees&#125;// 获取路由root根func (r *Router) getRoot(method string) methodTree &#123;\tif root, ok := r.trees[method]; ok &#123; return root\t&#125;\tr.trees[method] = methodTree&#123;method: method, paths: make(map[string]func(c *Context))&#125;\treturn r.trees[method]&#125;// 添加路由方法func (r *Router) addRoute(method, path string, ctx func(c *Context)) &#123;\troot := r.getRoot(method)\tif _, ok := root.paths[path]; ok &#123; log.Default().Println(path, &quot;is exist&quot;) return\t&#125;\troot.method = method\troot.paths[path] = ctx&#125;// Get Get方法func (r *Router) Get(path string, handler func(c *Context)) &#123;\tr.addRoute(http.MethodGet, path, handler)&#125;// Post Post方法func (e *Engine) Post(path string, handler func(c *Context)) &#123;\te.addRoute(http.MethodPost, path, handler)&#125; 修改Mygin&#x2F;engine.go文件123456789101112131415161718192021222324252627282930313233343536package myginimport (\t&quot;net/http&quot;)type Engine struct &#123;\tRouter&#125;func (e *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;\tif tree, ok := e.trees[r.Method]; ok &#123; if handler, ok := tree.paths[r.URL.Path]; ok &#123; handler(w, r) return &#125;\t&#125;\tw.Write([]byte(&quot;404 Not found! &quot;))&#125;// Default returns an Enginefunc Default() *Engine &#123;\treturn &amp;Engine&#123; Router&#123; trees: make(methodTrees, 2), &#125;&#125;&#125;// Run 启动方法start a http serverfunc (e *Engine) Run(addr string) &#123;\terr := http.ListenAndServe(addr, e)\tif err != nil &#123; return\t&#125;&#125; 相当于engine继承router，engine可以调用router中的方法。文件拆分开来，就不那么乱了。以后路由相关的功能就在router文件中编写，更加清晰。 上下文对于1个请求来说，无法就是接收http.Request的数据处理，然后将处理后的数据http.ResponseWriter返回。虽然响应的消息体(Body)不一样，但对于同一种类型比如JSON类型，消息头(Header)和消息体(Body)，而 Header 包含了状态码(StatusCode)，消息类型(ContentType)等几乎每次请求都需要重新写，所以进行封装，对于后续扩展和修改都非常必要。 用返回 JSON 数据作比较，感受下封装前后的差距。 封装前 12345678910obj = map[string]interface&#123;&#125;&#123; &quot;name&quot;: &quot;scott&quot;, &quot;password&quot;: &quot;1234&quot;,&#125;w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)w.WriteHeader(http.StatusOK)encoder := json.NewEncoder(w)if err := encoder.Encode(obj); err != nil &#123; http.Error(w, err.Error(), 500)&#125; 封装后 1234c.JSON(http.StatusOK, map[string][string]&#123; &quot;username&quot;: c.PostForm(&quot;username&quot;), &quot;password&quot;: c.PostForm(&quot;password&quot;),&#125;) 封装http.Request和*http.ResponseWriter**的方法，简化相关接口的调用，只是设计 Context 的原因之一。对于框架来说，还需要支撑额外的功能。例如，将来解析动态路由&#x2F;hello&#x2F;:name，参数:name的值放在哪呢？再比如，框架需要支持中间件，那中间件产生的信息放在哪呢？Context 随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由 Context 承载。因此，设计 Context 结构，扩展性和复杂性留在了内部，而对外简化了接口。路由的处理函数，以及将要实现的中间件，参数都统一使用 Context 实例， Context 就像一次会话的百宝箱，可以找到任何东西。 新建mygin&#x2F;context.go文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package myginimport (\t&quot;encoding/json&quot;\t&quot;net/http&quot;)type Context struct &#123;\tRequest *http.Request\tWriter http.ResponseWriter&#125;func writeContentType(w http.ResponseWriter, value []string) &#123;\theader := w.Header()\tif val := header[&quot;Content-Type&quot;]; len(val) == 0 &#123; header[&quot;Content-Type&quot;] = value\t&#125;&#125;func (c *Context) Status(code int) &#123;\tc.Writer.WriteHeader(code)&#125;func (c *Context) JSON(v interface&#123;&#125;) error &#123;\twriteContentType(c.Writer, []string&#123;&quot;application/json; charset=utf-8&quot;&#125;)\tencoder := json.NewEncoder(c.Writer)\terr := encoder.Encode(v)\tif err != nil &#123; c.Status(http.StatusInternalServerError)\t&#125;\tc.Status(http.StatusOK)\treturn err&#125;func (c *Context) Html(v string) error &#123;\twriteContentType(c.Writer, []string&#123;&quot;text/html; charset=utf-8&quot;&#125;)\tc.Status(http.StatusOK)\t_, err := c.Writer.Write([]byte(v))\treturn err&#125;func (c *Context) String(v string) error &#123;\twriteContentType(c.Writer, []string&#123;&quot;text/plain; charset=utf-8&quot;&#125;)\tc.Status(http.StatusOK)\t_, err := c.Writer.Write([]byte(v))\treturn err&#125; 在context中实现了JSON、Html、String方法 main.go文件修改 12345678910111213141516171819202122232425package mainimport (\t&quot;gophp/mygin&quot;)func main() &#123;\tengine := mygin.Default()\tengine.Get(&quot;/json&quot;, func(c *mygin.Context) &#123; c.JSON(map[string]interface&#123;&#125;&#123; &quot;name&quot;: &quot;zs&quot;, &quot;password&quot;: &quot;1234&quot;, &#125;)\t&#125;)\tengine.Get(&quot;/html&quot;, func(c *mygin.Context) &#123; c.Html(&quot;&lt;h1&gt;hello html!&lt;/h1&gt;&quot;)\t&#125;)\tengine.Get(&quot;/string&quot;, func(c *mygin.Context) &#123; c.String(&quot;string...&quot;)\t&#125;)\tengine.Run(&quot;:9501&quot;)&#125; 接下来看实际效果 1234567891011121314151617181920212223curl -i http://localhost:9501/jsonHTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Wed, 17 Jan 2024 05:52:28 GMTContent-Length: 32&#123;&quot;name&quot;:&quot;zs&quot;,&quot;password&quot;:&quot;1234&quot;&#125; ~ curl -i http://localhost:9501/htmlHTTP/1.1 200 OKContent-Type: text/html; charset=utf-8Date: Wed, 17 Jan 2024 05:52:36 GMTContent-Length: 20&lt;h1&gt;hello html!&lt;/h1&gt; ~ curl -i http://localhost:9501/stringHTTP/1.1 200 OKContent-Type: text/plain; charset=utf-8Date: Wed, 17 Jan 2024 05:52:42 GMTContent-Length: 9string...","tags":["Golang","Web"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"02.Mygin实现简单的路由","path":"/2022/01/26/mygin-day02.html","content":"本文是Mygin第二篇 目的: 实现路由映射 提供了用户注册静态路由方法（GET、POST方法） 基于上一篇 Mygin 实现简单Http 且参照Gin 使用了map数组实现简单路由的映射关系 不同的method对应一个组，Gin框架初始化时map时初始化9个，因为支持的http.method刚好为9个 1234567891011121314package http//Gin 中对应的9个方法const (\tMethodGet = &quot;GET&quot;\tMethodHead = &quot;HEAD&quot;\tMethodPost = &quot;POST&quot;\tMethodPut = &quot;PUT&quot;\tMethodPatch = &quot;PATCH&quot; // RFC 5789\tMethodDelete = &quot;DELETE&quot;\tMethodConnect = &quot;CONNECT&quot;\tMethodOptions = &quot;OPTIONS&quot;\tMethodTrace = &quot;TRACE&quot;) mygin路由功能实现 mygin&#x2F;engine.go12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package myginimport (\t&quot;log&quot;\t&quot;net/http&quot;)type Engine struct &#123;\ttrees methodTrees&#125;// 路由树type methodTrees map[string]methodTree// 路由节点type methodTree struct &#123;\tmethod string\tpaths map[string]http.HandlerFunc&#125;// 获取路由root根func (e *Engine) getRoot(method string) methodTree &#123;\tif root, ok := e.trees[method]; ok &#123; return root\t&#125;\te.trees[method] = methodTree&#123;method: method, paths: make(map[string]http.HandlerFunc)&#125;\treturn e.trees[method]&#125;// 添加路由方法func (e *Engine) addRoute(method, path string, handler http.HandlerFunc) &#123;\troot := e.getRoot(method) //是否已经在路由数上绑定，如果已经绑定就不在继续绑定\tif _, ok := root.paths[path]; ok &#123; log.Default().Println(path, &quot;is exist&quot;) return\t&#125; //将path与处理方法关系绑定\troot.method = method\troot.paths[path] = handler&#125;func (e *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; //对应method中的路由树\tif tree, ok := e.trees[r.Method]; ok &#123; //路由数中path映射 if handler, ok := tree.paths[r.URL.Path]; ok &#123; handler(w, r) return &#125;\t&#125; //在路由数中没有找到对应的路由\tw.Write([]byte(&quot;404 Not found! &quot;))&#125;// Get Get方法func (e *Engine) Get(path string, handler http.HandlerFunc) &#123;\te.addRoute(http.MethodGet, path, handler)&#125;// Post Post方法func (e *Engine) Post(path string, handler http.HandlerFunc) &#123;\te.addRoute(http.MethodPost, path, handler)&#125;// Default returns an Enginefunc Default() *Engine &#123;\treturn &amp;Engine&#123;trees: make(methodTrees, 2)&#125;&#125;// Run 启动方法start a http serverfunc (e *Engine) Run(addr string) &#123;\terr := http.ListenAndServe(addr, e)\tif err != nil &#123; return\t&#125;&#125; 我们重点介绍一下这部分的实现 首先定义了类型methodTrees，这是提供给框架用户的，用来定义路由映射的处理方法。我们在Engine中，添加了一张路由映射表router，key 由请求方法和静态路由地址构成，例如GET请求 “&#x2F;“ 在methodTrees中methodTrees[“GET”][“&#x2F;“]、”&#x2F;hello”&#x3D;&gt;methodTrees[“GET”][“&#x2F;hello”]、”&#x2F;hello”&#x3D;&gt;methodTrees[“POST”][“&#x2F;hello”]，这样针对相同的路由，如果请求方法不同,可以映射不同的处理方法(Handler)，value 是用户映射的处理方法。 当用户调用(*Engine).Get()方法时，会将路由和处理方法注册到映射表 router 中，(*Engine).Run()方法，是 ListenAndServe 的包装。 Engine实现的 ServeHTTP 方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法。如果查不到，就返回 **404 Not found!**。 mai测试n方法调用1234567891011121314151617181920package mainimport (\t&quot;mygin&quot;\t&quot;net/http&quot;)func main() &#123;\tengine := mygin.Default() engine.Get(&quot;/hello&quot;, func(writer http.ResponseWriter, request *http.Request) &#123; writer.Write([]byte(&quot;Mygin Get hello method&quot;))\t&#125;)\tengine.Post(&quot;/hello&quot;, func(writer http.ResponseWriter, request *http.Request) &#123; writer.Write([]byte(&quot;Mygin Post hello method&quot;))\t&#125;)\tengine.Run(&quot;:8088&quot;)&#125; curl请求测试123456~ curl 127.0.0.1:8088/helloMygin Get hello method#~ curl -X POST http://127.0.0.1:8088/helloMygin Post hello method# ~ curl -X POST http://127.0.0.1:8088/hello2404 Not found! 至此，整个Mygin框架的原型已经出来了。实现了路由映射表，提供了用户注册静态路由的方法，包装了启动服务的函数。当然，到目前为止，我们还没有实现比net&#x2F;http标准库更强大的能力，不用担心，很快就可以将动态路由、中间件等功能添加上去了。","tags":["Golang","Web"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"01.Mygin实现简单Http","path":"/2022/01/24/mygin-day01.html","content":"本篇是完全参考gin的功能，自己手动实现一个类似的功能，帮助自己理解和学习gin框架。目的:简单介绍net&#x2F;http库以及http.Handler接口,实现简单路由请求的功能。 目的 简单介绍net&#x2F;http库以及http.Handler接口 实现简单路由请求的功能 标准库启动Web服务先看用标准库怎样启动一个web服务 123456789import &quot;net/http&quot;func helloHandler(w http.ResponseWriter, r *http.Request) &#123;\tw.Write([]byte(&quot;hello world&quot;))&#125;func main() &#123;\thttp.HandleFunc(&quot;/hello&quot;, helloHandler)\thttp.ListenAndServe(&quot;:8088&quot;, nil)&#125; 设置路由我设置了一个 &#x2F;hello 的简单路由，GET请求后返回 hello world。 12 ~ curl 127.0.0.1:8088/hellohello world为什么请求路由能够返回hello world，这就要从Golang的http包ListenAndServe.go中查看了。 ListenAndServe源码查看我已经将源码上的注释翻译成了中文 1234567891011// ListenAndServe监听TCP网络地址addr，然后调用//使用处理程序处理传入连接的请求。//被接受的连接被配置为使能TCP keepalive。////处理程序通常为nil，在这种情况下使用DefaultServeMux。//// ListenAndServe总是返回一个非nil错误。func ListenAndServe(addr string, handler Handler) error &#123;\tserver := &amp;Server&#123;Addr: addr, Handler: handler&#125;\treturn server.ListenAndServe()&#125; 实现Handler接口 http包中HandleFunc的第二个参数是什么意思？点进官方包去看。12345package httptype Handler interface &#123; ServeHTTP(w ResponseWriter, r *Request)&#125; 看到第二个参数是要实现 Handler 接口的方法，根据路由匹配交给实现对应的方法处理。 engine.go编写基于此改造封装mygin&#x2F;engine.go 12345678910111213141516171819202122232425262728293031package myginimport (\t&quot;net/http&quot;)type Engine struct &#123;&#125;//ServeHTTP 方法func (e *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;\tswitch r.URL.Path &#123;\tcase &quot;/&quot;: w.Write([]byte(&quot;success &quot;))\tcase &quot;/hello&quot;: w.Write([]byte(&quot;hello world！ &quot;))\tdefault: w.Write([]byte(&quot;404 NOT FOUND&quot; + r.URL.Path + &quot; &quot;))\t&#125;&#125;func Default() *Engine &#123;\treturn &amp;Engine&#123;&#125;&#125;func (e *Engine) Run(addr string) &#123;\terr := http.ListenAndServe(addr, e)\tif err != nil &#123; return\t&#125;&#125; 可以看到我编写了一个engine.go文件，包含了ServeHTTP方法，也就是engine实现了http包中 Handler 接口。http.ListenAndServe第二个参数把engine对象传过去，在http在处理时，就会去调用engine中的ServeHTTP方法。 main.go中调用12345678package mainimport &quot;gophp/mygin&quot;func main() &#123;\tengine := mygin.Default()\tengine.Run(&quot;:8088&quot;)&#125; 编写好上诉代码后，启动main方法，可以看到我将 :8088当作地址传入调用engine.go中的Run方法，将 :8088 当作第一个参数传入http.ListenAndServe中，表示监听8088端口，第二个参数则是我们基于net&#x2F;http标准库实现Web框架的入口，也就是engine中的ServeHTTP方法。 curl请求1234 ~ curl 127.0.0.1:8088/hellohello world！ ~ curl 127.0.0.1:8088success 看到上诉结果，代表已经实现了最核心的第一步，在Golang中，不管什么web框架，所有的请求都是在此基础上运行的。赶快去试试吧。","tags":["Golang","Web","Mygin"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"About - pengbin","path":"/about/index.html","content":"关于我 个人信息姓名：彭彬&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;性别：男毕业院校：西南科技大学&emsp;&emsp;&emsp;&emsp;&emsp;学历：本科工作年限：8年&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;现居住地：重庆市联系电话：173-2044-7422&emsp;&emsp;&emsp;&emsp;邮 箱：&#x70;&#x65;&#x6e;&#x67;&#98;&#x69;&#110;&#x5f;&#x32;&#x30;&#x31;&#50;&#x40;&#x31;&#x36;&#51;&#x2e;&#x63;&#x6f;&#x6d; 技能描述 精通GoLang、PHP、JAVA语言基础及面向对象编程思想，有良好的规范编程习惯。 熟悉数据库原理，具有mysql数据库设计开发经验，了解数据库的配置管理、性能调优。 熟练使用GoLand、VSCode等开发工具,熟悉项目管理工具。 掌握uber&#x2F;fx、Gin、Gorm等主流框架，熟悉VUE、JQuery、Ajax、HTML5、CSS等技术。 熟悉常用的设计模式，如观察者、工厂、策略、代理等。 熟悉nginx配置，对nginx实现负载均衡、反向代理、正向代理也有一定的了解。 熟练掌握git、svn等团队协调开发工具。 熟悉Redis等缓存服务器集群环境的搭建，以及应用。 了解容器docker、Kubernetes的相关知识，以及云原生相关生态。 工作经验2022年10月 ~ 至今：重庆药羚科技有限公司 主要负责前期项目架构设计公共组件封装。 负责测试用例设计，指导组内成员，进行辅导和监督。 参与项目的搭建和主要模块的功能开发及优化。 负责技术难点的解决，把控项目进度。 2021年10月 ~ 2022年10月：重庆优税猫科技公司 主要负责项目的搭建和主要功能模块的开发和优化。 也负责日常的功能开发及优化。 负责协调解决系统出现的bug。 2019年10月 ~ 2021年10月：重庆国贵赛车科技公司 参与项目的搭建和主要模块的功能开发及优化。 进行测试用例设计，同时指导组内成员，进行辅导与监督。 进行日常的功能开发及优化。 负责协调解决测试过程中遇到的各种问题。 解决测试提出的缺陷、协助项目经理把控项目进度。 2018年03月 ~ 2019年10月：重庆森梅医疗科技有限公司 参与主要模块的功能开发及优化。 负责与研制方沟通与协调，协同完成测试工作。 协同进行质量整改，确保测试工作的圆满完成。 负责协调解决测试过程中遇到的各种问题。 2016年10月 ~ 2018年3月：重庆龙易购科技公司 参与主要模块的功能开发及优化。 负责与研制方沟通与协调，协同完成测试工作。 协同进行质量整改，确保测试工作的圆满完成。 工作经历PMS项目2022&#x2F;10 ~ 2014&#x2F;02：于重庆药羚科技有限公司开发，团队项目，维护至今&emsp;该项目是医药行业项目从销售到交付的项目管理系统软件。覆盖医药研发全生命周期、多业务场景的新一代项目运营管理工具专注为医药行业项目运营管理数智化转型赋能。灵活丰富的自定义配置，更加契合业务的实际情况，覆盖从立项到上市的药物研发全生命周期。支持报工、派工双模式，工时填报方便快捷，工时统计实时分析。灵活严密的权限管控实现数据安全隔离防控，多种专业技术手段全方位保障系统安全。依据目标拆解任务，支持模板一键任务创建，明确人权责，通过里程碑有效管理项目进度、收入、成本、资源、交付，保障项目顺利推进。 众乐邦2021&#x2F;10 ~ 2022&#x2F;10：于重庆优税猫科技公司开发，团队项目该项目主要是灵活用工数字化薪税管理平台，专业为企业提供酬劳结算、薪税合规、完税凭证等服务，助力企业实现用工成本优化、组织管理效率提升。一站式解决企业灵活用工对私结算难题。助力企业降本增效，合规完税凭证，用工成本优化，酬劳发放合规。 监控大屏项目2022&#x2F;01 ~ 2022&#x2F;04：于重庆优税猫科技公司开发该项目主要将数据可视化，该项目分为一期对内和二期对监管平台。一期主要分为资金流水模块、发票模块、任务模块、协议模块、自由职业者模块、企业活跃度等模块，每个模块可根据不同的维度分别统计。对内展示版本主要注重资金流水和任务开票模块。监管平台主要注重企业的分布状态每个月的纳税情况等。 亚马逊销售系统2021&#x2F;03 ~ 2021&#x2F;10：于重庆国贵赛车科技公司开发该项目主要为销售运营提供listing上下架管理、listing库存、运费、图片、价格管理。黑名单listing开发、以及从亚马逊报表获取、店铺同步、feed功能。发布listing到亚马逊，以及亚马逊A+功能。以及从公司价格系统获取价格，运费系统获取运费，不同的菜单有不同的权限点，根据不同的角色通过与公司钉钉绑定获取不同权限，角色离职后不能登陆。A+功能模块：根据亚马逊A+Content接口，以及亚马逊后台A+后台管理系统，开发A+模块，方便运营在平台上编辑亚马逊A+，前端页面可以上下排序根据不同模块自由组合。同时还可以通过ajax请求同步产品库中的页面。根据运营填写的A+页面数据，解析编辑器中的字符串为亚马逊A+支持的字符json数据。提交时根据页面中的图片，处理图片及获取图片大小信息，根据不同的模块采用工厂模式实例化出不同的类处理对应的数据，并拼接为json数据存入数据库。然后根据接口请求创建一个swoole任务，根据亚马逊发送A+流程，发送A+数据，并把返回结果及时更新。 B2C自营销售站点开发2019&#x2F;10 ~ 2021&#x2F;03：于重庆国贵赛车科技公司开发该项目为公司多站点自营项目，有UK、US、AU、ES、DE等站点分为后台管理模块和前台销售展示模块。后台管理模块根据钉钉授权绑定登陆，同时根据不同的模块参数，对不同的人员通过内部系统进行相应的授权，后台模块包含对产品的管理，以及多仓库的设置。从公司价格系统获取价格及库存操作。点击同步后通过接口调取swoole的woker出异步处理数据，同步结果通知到钉钉群。以及后台设置Shopify参数，Shopify站点仓库一一对应功能。导出feed模块，根据所选条件可生成不同的feed表头。 Shopify销售系统开发2019&#x2F;10 ~ 2021&#x2F;03：于重庆国贵赛车科技公司开发该项目从B2C自营站点选择一个站点的数据，通过Shopify接口上传到shopify中。主要包含sku及对应的商品数据上传，历史订单的上传，sku商品的价格及库存同步，代理商数据导入等功能。同时开发出针对该系统的接口。定时将B2C中的数据更新到Shopify中，每天定时同步sku商品的价格和库存到shopify中，也可手动出发任务。 CKD肾内慢病管理系统2018&#x2F;03 ~ 2019&#x2F;10：于重庆森梅医疗科技有限公司开发该项目主要分为CKD&#x2F;PD两类患者管理、综合搜索模块、质控管理、院外管理。包含患者信息的信息管理及相关量表，用药记录等有关患者信息的管理平台。医生护士登录权限管理，主要分主任医生，普通医生，护士长，普通护士。根据登录的角色，显示对应的菜单。 质控管理主要包含患者的信息分析，病情分析，管理信息分析，疑似病患分析等功能。综合搜索模块：主要分为筛查模板及展示模板。筛查模板，根据六个维度，选择不同的条件，以及条件的动态组合，搜索出满足条件的患者。展示模板，根据筛查模板，筛选出来的患者，自由选择展示字段，查询出结果。可以选择下载excel，后台根据结果生成excel，将excel数据以二进制形式，发送到前端，前端接收后，下载excel。 科研系统2019&#x2F;03 ~ 2019&#x2F;10：于重庆森梅医疗科技有限公司开发该项目主要分为项目管理、患者管理、数据导出3个模块。项目管理：根据不同的科研目的创建不同项目，创建项目时，选择不同的访视表单，以及多个访视的开始时间，及持续时间。患者管理：从ckd平台入组患者到科研平台，或者从医院端接口拉取数据。到项目中，一个患者同一项目可入组一次，同一患者可入职多个项目。根据项目配置的表单信息，实时统计完成进度，以及根据项目访视日期，实时统计出过期，和本期访视数量。数据导出：根据填写的访视表单信息，实时计算出可以导出的访视表单excel，选择相应的导出字段，根据字段信息，将满足条件的患者信息和填写的访视表单信息，后台生成excel，将excel数据以二进制形式，发送到前端，前端接收后，下载excel。excel保存到服务器30天，可重复下载，超过30天后，后台脚本将清理excel。并记录日志。 又又帮乳腺管理平台2018&#x2F;10 ~ 2019&#x2F;02：于重庆森梅医疗科技有限公司开发该项目主要分为患教课程管理、用户管理、账户设置，权限管理模块管理平台账号登录后台，可以看到所有的患教课程，可以看到所有的用户信息。管理平台不能选择新增用户，医院平台，可以新增用户，一个医院一个患者通过手机号只能注册一个账号，根据用户情况可设置相应的用户对应类型，不设置默认可看任意类型，并生成对应6位数的邀请码，用户根据手机发送的邀请码或者当面告知的邀请码，在手机app端绑定医院。该用户就能看到医院对应类型的患教课程，实现精准推送课程。管理平台发送的患教课程，不区分医院，所有用户也可根据设置的相应类型，查看相应的患教课程。 龙智造工业云平台2016&#x2F;10 ~ 2018&#x2F;03：于重庆龙易购科技有限公司开发该项目分为玩采购大厅&#x2F;能力大厅：登陆时，能根据企业用户注册时选择的行业，将相关行业的信息，优先展示采购&#x2F;能力大厅信息（千人千面）功能。未登陆时默认显示。发布采购&#x2F;能力信息，当企业用户登陆时自动读取企业信息，并将信息自动填入输入框，用户可修改自动输入的信息。工业品商城：根据行业分类展示工业品信息，工业品详情自动匹配相关工业品信息，用户未登陆时，隐藏电话号码中间4位，引导用户注册。 重庆市智慧园区公共服务平台2017&#x2F;06 ~ 2018&#x2F;03：于重庆龙易购科技有限公司开发该项目通过线上线下融合推广及运营的模式，助推全市产业快速转型升级，提升产业竞争力；通过强大的服务能力和大量数据汇集，形成全市产业大数据，主要模块有个人中心：首页，统计个人发布各个模块的数量及待审核数量，个人用户能看到企业的资料完善等情况，包含我的订单模块、我的需求模块、我的供应模块、企业管理中心模块、以及个人店铺的设置等功能。痛点库：登陆后能发布企业痛点信息，后台审核通过后，将痛点信息展示，本模块采用ajax加载，当点击筛选条件时，ajax动态加载页面信息。产能共享：所在园区和所在地区联动，当选择地区时，实时更新所在园区，反之亦然。进入详情时，能根据用户浏览记录，自动推荐相关能力信息。 自我评价 学习能力强，思路清晰，善于从整体上分析、把握复杂事物，对细节难题具备快速钻研解决能力； 有多年的工作经历与社会阅历，能快速地融入、凝聚团队； 良好的表达与沟通能力，积极主动，对工作尽心尽责； 比较独立，不怕吃苦，能够迎难而上。 求职意向目前状态为：在职，考虑换工作，1个月内可到岗。"},{"title":"序言","path":"/wiki/my-gorm/index.html","content":"对象和数据库是如何映射 数据库 对象表 表(table) 类(struct) 记录(record, row) 对象 (object) 字段(field, column) 对象属性(attribute) 现在看起来比较抽象，举个例子就形象很多了。比如在Mysql数据库中： 123CREATE TABLE `Student` (`Name` text, `Scope` integer);INSERT INTO `Student` (`Name`, `Scope`) VALUES (&quot;张三&quot;, 98);SELECT * FROM `Student`; 如果我们使用了ORM框架，在Go中的写法如下: Student.go123456789type Student struct &#123;\tName string\tScope int&#125;mygorm.CreateTable(&amp;Student&#123;&#125;)mygorm.Save(&amp;Student&#123;&quot;张三&quot;, 98&#125;)var students []Studentmygorm.Find(&amp;students) ORM 相当于是对象与数据库的映射关系，可以把数据库中的一条条数据想象成一个个对象，一张表的数据，相当于相同对象的集合，我们通过操作对象集合的方法，从而实现对关系型数据库的操作。 如何实现一个 ORM 框架根据上面的例子，看到对数据库操作，传递了对象从而实现对关系型数据库的操作。但是ORM 框架是怎么知道上面的 “张三”对应的是数据库中的Name的，这个时候就不得不提到反射了，Go 语言的反射机制(reflect)，通过反射，可以获取到对象对应的结构体名称，成员变量、方法等信息。 例如在下面的例子中： main.go1234567891011121314151617181920212223package mainimport (\t&quot;fmt&quot;\t&quot;reflect&quot;)type Student struct &#123;\tName string\tScope int&#125;func main() &#123; valueOf := reflect.ValueOf(&amp;Student&#123;&quot;张三&quot;, 98&#125;).Elem() for i := 0; i &lt; valueOf.NumField(); i++ &#123; fieldValue := valueOf.Field(i) fieldType := valueOf.Field(i).Type() fmt.Println(fieldValue, fieldType)\t&#125;\t&#125; 上面的测试代码，会把字段和字段类型输出。 123~ go run student.go张三 string98 int reflect.ValueOf() 获取指针对应的反射值。 (reflect.Type).Field(i).Type() 获取第 i 个成员变量类型。 (reflect.Type).Field(i) 获取第 i 个成员变量。 … 关于MyGormMyGorm主要基于MySQL开发 简单的增删查改使用 ORM 替代 SQL 语句是很简单的，但是实际应用中不仅仅是对单表进行CURD，比如复杂的多表关联查询，ORM 也需要支持，因此，设计实现一个 ORM 框架，先从简单的入手。万丈高楼平地起，一砖一瓦皆根基。就像Mygin一样。 Go 语言中使用比较广泛 ORM 框架是 gorm 和 xorm。除了基础的功能，比如表的操作，记录的增删查改，gorm 还实现了关联关系(一对一、一对多等)，回调插件等；xorm 实现了读写分离(支持配置多个数据库)，数据同步，导入导出等。 MyGorm目的主要是了解 ORM 框架设计的原理,具体实现的功能有： 表的创建、删除、迁移。 记录的增删查改，查询条件的链式操作。 单一主键的设置(primary key)。 钩子(在创建&#x2F;更新&#x2F;删除&#x2F;查找之前或之后) 事务(transaction)。 …","tags":[null,null,null],"categories":[null,null]},{"title":"核心引擎 · log日志","path":"/wiki/my-gorm/mygorm-core-log.html","content":"本篇是Go从零实现ORM框架MyGORM核心篇的第一篇。 目的 MyGorm核心日志的封装。 Log日志MyGorm核心实现之log日志记录，一个好的架构，离不开详细日志，否则出现问题的时候抓眼瞎。因此在实现核心功能前，先实现一个简单的log日志记录。 为什么不直接使用原生的 log 库,log 标准库没有日志分级，不打印文件和行号，这就意味着我们很难快速知道是哪个地方发生了错误。 功能 支持日志分级。 不同层级日志显示时使用不同的颜色区分。 显示打印日志代码对应的文件名和行号。 首先使用命令mkdir mygorm创建一个名为 mygorm文件夹,然后执行 go mod init mygorm并新建文件 log.go，用于放置和日志相关的代码。 现在的代码结构为: 1234mygorm/\tlog/ |--log.go |--go.mod 颜色通常，我们会对不同等级的日志输出不同的颜色来区分。 12fmt.Printf(&quot;\\033[1;31;40m%s\\033[0m &quot;,&quot;Red.&quot;)fmt.Printf(&quot;\\033[1;37;41m%s\\033[0m &quot;,&quot;Red.&quot;) 第一行是红字黑底，第二行红底白字。我们来解析\\033[1;31;40m%s\\033[0m 这个字符串中的字符分别代表了什么。 \\033：\\ 表示转义，\\033 表示设置颜色。 [1;31;40m：定义颜色，[ 表示开始颜色设置，m 为颜色设置结束，以 ; 号分隔。1 代码，表示显示方式，31 表示前景颜色（文字的 颜色），40 表示背景颜色。 \\033[0m：表示恢复终端默认样式。 123456789101112131415161718192021// 前景 背景 颜色// ---------------------------------------// 30 40 黑色// 31 41 红色// 32 42 绿色// 33 43 黄色// 34 44 蓝色// 35 45 紫红色// 36 46 青蓝色// 37 47 白色// 3 位前景色, 4 位背景色// 代码 意义// -------------------------// 0 终端默认设置// 1 高亮显示// 4 使用下划线// 5 闪烁// 7 反白显示// 8 不可见 根据上面的颜色，我设置了4种日志级别,代码我已经上传github，点击即可跳转。 log日志代码 my-gorm&#x2F;log&#x2F;log.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package logimport (\t&quot;io&quot;\t&quot;log&quot;\t&quot;os&quot;\t&quot;sync&quot;)type LevelFlag uintconst (\tDebugLevel LevelFlag = iota\tInfoLevel\tWarnLevel\tErrorLevel\tDisableLevel)// 颜色设置var debugLog = log.New(os.Stdout, &quot;\\033[1;37;40m[mygorm-debug]&quot;, log.Ldate|log.Lmicroseconds|log.Lshortfile)var infoLog = log.New(os.Stdout, &quot;\\033[1;32;40m[mygorm-info]&quot;, log.Ldate|log.Lmicroseconds|log.Lshortfile)var warnLog = log.New(os.Stdout, &quot;\\033[1;33;40m[mygorm-warn]&quot;, log.Ldate|log.Lmicroseconds|log.Lshortfile)var errorLog = log.New(os.Stdout, &quot;\\033[1;31;40m[mygorm-error]&quot;, log.Ldate|log.Lmicroseconds|log.Lshortfile)var loggers = []*log.Logger&#123;debugLog, infoLog, warnLog, errorLog&#125;var mu sync.Mutex// 日志方法var (\tDebug = debugLog.Println\tDebugF = debugLog.Printf\tInfo = infoLog.Println\tInfoF = infoLog.Printf\tWarn = warnLog.Println\tWarnF = warnLog.Printf\tError = errorLog.Println\tErrorF = errorLog.Printf)// SetLogLevel 设置日志级别func SetLogLevel(level LevelFlag) &#123;\t//加锁\tmu.Lock()\t//释放锁\tdefer mu.Unlock()\t//先把所有的日志级别允许输出\tfor _, logger := range loggers &#123; logger.SetOutput(os.Stdout)\t&#125;\t//设置的level 大于err 说明err以下的都不输出\tif level &gt; ErrorLevel &#123; errorLog.SetOutput(io.Discard)\t&#125;\t//只有 level 大于 warn才会输出，只有err 级别才会输出\tif level &gt; WarnLevel &#123; warnLog.SetOutput(io.Discard)\t&#125;\tif level &gt; InfoLevel &#123; infoLog.SetOutput(io.Discard)\t&#125;\tif level &gt; DebugLevel &#123; debugLog.SetOutput(io.Discard)\t&#125;&#125; log日志测试代码 my-gorm&#x2F;log&#x2F;log_test.go 12345678910111213141516171819package logimport (\t&quot;testing&quot;)func TestSetLogLevel(t *testing.T) &#123;\t//设置级别为err\tSetLogLevel(ErrorLevel)\tError(&quot;error TestSetLogLevel&quot;) //会输出\tInfo(&quot;info TestSetLogLevel&quot;) //不会输出&#125;func TestSetLogLevel2(t *testing.T) &#123;\t//设置级别为info\tSetLogLevel(InfoLevel)\tError(&quot;error TestSetLogLevel2&quot;) //会输出\tInfo(&quot;info TestSetLogLevel&quot;) //会输出&#125; log日志测试输出 TestSetLogLevel方法输出 TestSetLogLevel2方法输出 这样就实现了一个简单的日志级别输出。","tags":[null,null,null],"categories":[null,null]},{"title":"核心引擎 · Session会话","path":"/wiki/my-gorm/mygorm-core-session.html","content":"Session会话所有的操作都要先获得一个mysql的session会话，因此封装一个session用于实现与数据库的交互。新建session文件夹并在session文件夹新建session.go文件。 现在的代码结构为: 1234567mygorm/\tlog/ |--log.go |--log_test.go\tsession/ |--session.go\t|--go.mod Session会话管理 my-gorm&#x2F;session&#x2F;session.go 1234567891011121314151617181920212223242526272829303132333435363738package sessionimport (\t&quot;database/sql&quot;\t&quot;strings&quot;)// Session 包含一个数据库连接（db）、SQL语句构建器（sql）和SQL变量列表（vars）。type Session struct &#123;\tdb *sql.DB\tsql strings.Builder\tvars []interface&#123;&#125;&#125;// New 创建并返回一个新的 Session 实例，接受一个数据库连接作为参数。func New(db *sql.DB) *Session &#123;\treturn &amp;Session&#123;db: db&#125;&#125;// Reset 重置会话，清空之前的SQL语句和变量。func (s *Session) Reset() &#123;\ts.sql.Reset()\ts.vars = nil&#125;// GetDB 返回当前会话的数据库连接。func (s *Session) GetDB() *sql.DB &#123;\treturn s.db&#125;// Raw 一个 SQL 查询字符串和可变数量的参数，并将它们添加到 Session 结构体的内部状态func (s *Session) Raw(sql string, values ...interface&#123;&#125;) *Session &#123;\ts.sql.WriteString(sql)\ts.sql.WriteString(&quot; &quot;)\ts.vars = append(s.vars, values...)\treturn s&#125; Session 结构体包含了一个指向数据库连接的指针(db)，一个用于构建SQL语句的字符串构建器(sql)和一个用于存储SQL语句中的变量的切片(sqlVars)。 New 函数是一个构造函数，用于创建并返回一个新的 Session 实例，接受一个数据库连接作为参数。 Reset 方法用于重置会话状态，清空之前构建的SQL语句和变量。 GetDB 方法返回当前会话的数据库连接。 这个包的目的是为了提供一个简单的会话管理工具，使得在应用程序中执行数据库操作更加方便和模块化。它使用了Go语言的database&#x2F;sql包来处理数据库连接。 Session会话SQL 操作在基础 Go连接Mysql 中，介绍了Exec()、Query() 和 QueryRow() 这三个原生方法，所以接下来就封装这三个方法。 my-gorm&#x2F;session&#x2F;session.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Exec 执行数据库写操作，并返回 sql.Result 对象和可能的错误func (s *Session) Exec() (sql.Result, error) &#123; // 在函数返回前调用 Reset 方法，确保资源清理 defer s.Reset() // 调用 GetDB 方法获取数据库连接，执行 SQL 语句并返回结果 r, err := s.GetDB().Exec(s.sql.String(), s.vars...) if err != nil &#123; // 如果发生错误，记录错误信息 log.Error(err) &#125; // 记录调试信息，包括执行的 SQL 语句和参数 log.Debug(s.sql.String(), s.vars) return r, err&#125;// Query 执行数据库查询操作，并返回 *sql.Rows 对象和可能的错误func (s *Session) Query() (*sql.Rows, error) &#123; // 在函数返回前调用 Reset 方法，确保资源清理 defer s.Reset() // 调用 GetDB 方法获取数据库连接，执行 SQL 语句并返回结果集 rows, err := s.GetDB().Query(s.sql.String(), s.vars...) if err != nil &#123; // 如果发生错误，记录错误信息 log.Error(err) &#125; return rows, err&#125;// QueryRow 执行数据库查询操作，并返回 *sql.Row 对象func (s *Session) QueryRow() *sql.Row &#123; // 在函数返回前调用 Reset 方法，确保资源清理 defer s.Reset() // 调用 GetDB 方法获取数据库连接，执行 SQL 语句并返回单行结果 row := s.GetDB().QueryRow(s.sql.String(), s.vars...) // 记录调试信息，包括执行的 SQL 语句和参数 log.Debug(s.sql.String(), s.vars) return row&#125; Exec： 执行不返回行的 SQL 查询（例如 INSERT、UPDATE、DELETE）。它返回一个 sql.Result 和一个错误。 Query： 执行返回行的 SQL 查询（例如 SELECT）。它返回一个 *sql.Rows 和一个错误。 QueryRow： 执行预期返回单个行的 SQL 查询。它返回一个 *sql.Row。 测试在session目录下新增session_test.go测试文件，用于测试方法。 现在的代码结构为: 12345678mygorm/\tlog/ |--log.go |--log_test.go\tsession/ |--session.go |--session_test.go\t|--go.mod my-gorm&#x2F;session&#x2F;session_test.go12345678910111213141516171819202122232425262728293031323334353637383940414243package sessionimport (\t&quot;database/sql&quot;\t_ &quot;github.com/go-sql-driver/mysql&quot;\t&quot;github.com/scott-pb/mygorm/log&quot;\t&quot;testing&quot;)func TestSession_QueryRowQuery(t *testing.T) &#123;\t// 打开 MySQL 数据库连接\tdb, err := sql.Open(&quot;mysql&quot;, &quot;root:123456@tcp(127.0.0.1:3306)/my-gorm&quot;)\tif err != nil &#123; log.Error(err) return\t&#125;\t// 设置与数据库的最大打开连接数\tdb.SetMaxOpenConns(100)\t// 设置空闲中的最大连接数\tdb.SetMaxIdleConns(10)\t// 创建一个新的 Session 实例\tsession := New(db)\t// 定义 User 结构体，用于扫描查询结果\ttype User struct &#123; id uint // 用户 ID name string // 用户名 birthday string // 出生日期 gender uint8 // 性别\t&#125;\tvar user User\t// 查询数据库表 mg_user 中的第一行数据\trow := session.Raw(&quot;select * from mg_user limit 1&quot;).QueryRow()\t// 扫描查询结果并将数据填充到 User 结构体中\trow.Scan(&amp;user.id, &amp;user.name, &amp;user.birthday, &amp;user.gender)\t// 输出查询到的用户信息\tlog.Info(user)&#125; 上面的代码是一个 Go 语言的测试函数，用于测试数据库查询功能。 导入了必要的包： database&#x2F;sql：用于与数据库进行交互。 _ “github.com&#x2F;go-sql-driver&#x2F;mysql”：这是一个 MySQL 驱动程序的匿名导入，用于注册 MySQL 驱动程序，使得 sql.Open 函数能够打开 MySQL 数据库连接。 github.com&#x2F;scott-pb&#x2F;mygorm&#x2F;log：上一篇的日志包，用于记录日志信息。 testing：Go 语言的测试框架包。 定义一个名为 TestSession_QueryRowQuery 的测试函数。 在测试函数中进行了以下操作： 使用 sql.Open 函数打开了一个 MySQL 数据库连接，连接地址为 “root:123456@tcp(127.0.0.1:3306)&#x2F;my-gorm”。如果打开连接时出现错误，则记录错误信息并返回。 使用 db.SetMaxOpenConns 和 db.SetMaxIdleConns 方法设置了数据库连接池的最大打开连接数和最大空闲连接数。 创建了一个新的 Session 实例，传入了已打开的数据库连接。定义了一个结构体 User，用于存储从数据库查询结果中获取的用户信息。调用 session.Raw(“select * from mg_user limit 1”).QueryRow() 方法执行了一条 SQL 查询，限制返回结果为数据库表 mg_user 中的第一行数据，并返回一个 *sql.Row 对象。 使用 row.Scan 方法将查询结果中的字段值扫描并赋值给 User 结构体中的字段。 最后，使用日志包中的 log.Info 方法输出了查询到的用户信息。 go test测试 1go test 测试结果如下图： 可以看到执行时log日志记录了sql语句，且对应文件位置。","tags":[null,null,null],"categories":[null,null]},{"title":"SQL方言 · mysql","path":"/wiki/my-gorm/mygorm-dialect-mysql.html","content":"简介方言是指针对特定数据库产品所实现的 SQL 语言的变体或扩展。每种数据库产品都有其特定的 SQL 方言，例如 MySQL、PostgreSQL、SQLite、Oracle 等。 好处 数据库特性支持： 不同的数据库产品具有不同的特性和功能，SQL 方言可以充分利用和支持这些特性，使得开发者能够更好地利用目标数据库提供的功能。 性能优化： SQL 方言可以针对特定数据库的性能特点进行优化。通过使用数据库特定的 SQL 语法和特性，可以提高 SQL 查询的执行效率，从而提升系统的整体性能。 功能扩展： SQL 方言通常会在标准 SQL 的基础上进行扩展，以支持更丰富的功能和操作。这些扩展可以使得开发者能够更方便地实现复杂的数据操作和查询需求。 兼容性： SQL 方言通常会考虑到特定数据库的版本和兼容性要求，从而确保 SQL 语句在目标数据库上能够正确执行，并且在不同的数据库产品之间能够保持一定程度的兼容性。 安全性： SQL 方言可以提供针对特定数据库产品的安全特性和机制，从而帮助开发者防止 SQL 注入等安全漏洞。 总的来说，SQL 方言的存在可以使得开发者更好地利用目标数据库的功能和性能优势，提高开发效率和系统性能，并且保证数据操作的安全性和兼容性。 mysql方言本文是用mysql作为演示，所以先在MyGorm中新建文件夹dialect并新建文件mysql.go和 dialect.go 现在的代码结构为: 12345678910111213mygorm/ dialect/ |mysql.go\tlog/ |--log.go |--log_test.go\tsession/ |--session.go |--session_test.go |dialect.go\t|engine.go |engine_test.go\t|--go.mod 下面是dialect代码 mygorm&#x2F;dialect.go dialect/dialect.go12345678910111213141516171819202122package dialectimport &quot;reflect&quot;// Dialect 定义了数据库方言的接口type Dialect interface &#123;\tGetName() string // GetName 返回数据库方言的名称\tDataTypeOf(field reflect.Value) string // DataTypeOf 返回给定字段的数据库数据类型&#125;var dialectMap = make(map[string]Dialect) // dialectMap 用于存储数据库方言// RegisterDialect 用于注册数据库方言func RegisterDialect(name string, dialect Dialect) &#123;\tdialectMap[name] = dialect // 将数据库方言与其名称关联存储到 map 中&#125;// GetDialect 用于获取数据库方言func GetDialect(name string) (dialect Dialect, ok bool) &#123;\tdialect, ok = dialectMap[name] // 根据名称从 map 中获取数据库方言\treturn&#125; 这段代码定义了一个数据库方言的接口 Dialect，其中包含了获取方言名称和数据类型的方法。通过 RegisterDialect 函数可以注册新的数据库方言，并将其与名称关联存储在 dialectMap 中。GetDialect 函数用于根据名称获取已注册的数据库方言。这样的设计使得代码具有扩展性，可以方便地支持不同的数据库方言。 mygorm&#x2F;dialect&#x2F;mysql.go dialect/mysql.go1234567891011121314151617181920212223242526272829303132333435363738394041424344package dialectimport (\t&quot;fmt&quot;\t&quot;reflect&quot;\t&quot;time&quot;)// mysql 实现了 Dialect 接口，用于表示 MySQL 数据库的方言type mysql struct &#123;&#125;// GetName 返回 MySQL 数据库方言的名称func (m *mysql) GetName() string &#123;\treturn &quot;mysql&quot;&#125;// DataTypeOf 返回给定字段的 MySQL 数据类型func (m *mysql) DataTypeOf(field reflect.Value) string &#123;\tswitch field.Kind() &#123;\tcase reflect.Bool: return &quot;boolean&quot; // 布尔类型映射为 boolean\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uintptr: return &quot;integer&quot; // 整数类型映射为 integer\tcase reflect.Int64, reflect.Uint64: return &quot;bigint&quot; // 长整型映射为 bigint\tcase reflect.Float32, reflect.Float64: return &quot;double&quot; // 浮点类型映射为 double\tcase reflect.String: return &quot;varchar(255)&quot; // 字符串类型映射为 varchar(255)\tcase reflect.Array, reflect.Slice: return &quot;longblob&quot; // 数组或切片类型映射为 longblob\tcase reflect.Struct: if _, ok := field.Interface().(time.Time); ok &#123; return &quot;DATETIME&quot; // 时间类型映射为 DATETIME &#125;\tdefault: // 如果是其他类型，则抛出异常 panic(fmt.Sprintf(&quot;无效的 SQL 类型 %s (%s)&quot;, field.Type().Name(), field.Kind()))\t&#125;\t// 如果无法处理字段类型，则抛出异常\tpanic(fmt.Sprintf(&quot;无效的 SQL 类型 %s (%s)&quot;, field.Type().Name(), field.Kind()))&#125; 这段代码定义了一个 mysql 结构体，实现了 Dialect 接口的方法。通过实现 GetName 方法返回 MySQL 数据库方言的名称，实现 DataTypeOf 方法返回给定字段的 MySQL 数据类型。根据字段的类型，选择合适的 MySQL 数据类型进行映射。 init() 函数，用于在程序启动时注册 MySQL 数据库方言。具体来说，init() 函数会在程序运行时自动执行，并将 MySQL 方言注册到方言映射表中，这样在后续的数据库操作中就可以根据数据库类型来选择合适的方言。 通过调用 RegisterDialect 函数将 MySQL 方言注册到方言映射表中，以便在后续的数据库操作中能够正确地选择和使用 MySQL 方言。 这种方式可以确保在程序启动时，MySQL 方言已经注册好，后续的数据库操作可以直接使用 MySQL 方言而无需额外的注册操作，提高了代码的可用性和易用性。","tags":[null,null,null],"categories":[null,null]},{"title":"核心引擎 · Engine引擎","path":"/wiki/my-gorm/mygorm-core-engine.html","content":"Engine引擎Session 负责与数据库的交互，那交互前的准备工作（比如连接&#x2F;测试数据库），交互后的收尾工作（关闭连接）等就交给 Engine 来负责了。Engine 是 GeeORM 与用户交互的入口。代码位于根目录的 engine.go现在的代码结构为: 123456789mygorm/\tlog/ |--log.go |--log_test.go\tsession/ |--session.go |--session_test.go\t|engine.go\t|--go.mod 下面是engine引擎具体代码 mygorm&#x2F;engine.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mygormimport (\t&quot;database/sql&quot;\t_ &quot;github.com/go-sql-driver/mysql&quot;\t&quot;github.com/scott-pb/mygorm/log&quot;\t&quot;github.com/scott-pb/mygorm/session&quot;)// Engine 是一个数据库引擎，包含一个数据库连接。type Engine struct &#123;\tdb *sql.DB&#125;// NewEngine 创建并返回一个新的 Engine 实例，接受数据库驱动名称和数据源字符串作为参数。func (e *Engine) NewEngine(driver, source string) (*Engine, error) &#123;\t// 使用给定的驱动名称和数据源字符串打开数据库连接。\tdb, err := sql.Open(driver, source)\tif err != nil &#123; log.Error(err) return nil, err\t&#125;\t// 确保连接成功。\tif err = db.Ping(); err != nil &#123; log.Error(err) return nil, err\t&#125;\t// 打印连接成功信息。\tlog.Info(&quot;connect database success&quot;)\t// 返回一个新的 Engine 实例。\treturn &amp;Engine&#123; db: db,\t&#125;, nil&#125;// GetSession 返回一个新的会话，该会话绑定到当前引擎的数据库连接。func (e *Engine) GetSession() *session.Session &#123;\treturn session.New(e.db)&#125;// Close 关闭当前引擎的数据库连接。func (e *Engine) Close() &#123;\t// 关闭数据库连接，并处理可能发生的错误。\tif err := e.db.Close(); err != nil &#123; log.Error(&quot;close database failed&quot;, err) return\t&#125; // 打印关闭成功信息。\tlog.Info(&quot;close database success&quot;)&#125; Engine 结构体代表了数据库引擎，包含一个指向数据库连接的指针。 NewEngine 方法是一个工厂方法，用于创建并返回一个新的 Engine 实例，接受数据库驱动名称和数据源字符串作为参数。它通过给定的驱动名称和数据源字符串打开数据库连接，并确保连接成功。 GetSession 方法返回一个新的会话，该会话绑定到当前引擎的数据库连接。这个方法调用了 session.New 函数来创建会话对象。 Close 方法关闭当前引擎的数据库连接。如果关闭过程中发生错误，它会打印错误信息。 测试新建测试文件 engine_test.go my-gorm&#x2F;engine_test.go123456789101112131415161718192021222324252627282930313233343536package mygormimport (\t&quot;github.com/scott-pb/mygorm/log&quot;\t&quot;testing&quot;)func TestEngine(t *testing.T) &#123;\t// 创建一个新的数据库引擎实例\tengine, _ := NewEngine(&quot;mysql&quot;, &quot;root:123456@tcp(127.0.0.1:3306)/my-gorm&quot;)\t// 延迟关闭数据库引擎连接\tdefer engine.Close()\t// 获取一个数据库会话\ts := engine.GetSession()\t// 执行一条 SQL 查询，并获取结果的单行数据\tresult := s.Raw(&quot;select * from mg_user&quot;).QueryRow()\t// 定义一个 User 结构体，用于存储从数据库查询结果中获取的用户信息\ttype User struct &#123; id uint // 用户 ID name string // 用户名 birthday string // 出生日期 gender uint8 // 性别\t&#125;\tvar user User\t// 将查询结果中的字段值扫描并赋值给 User 结构体中的字段\tif err := result.Scan(&amp;user.id, &amp;user.name, &amp;user.birthday, &amp;user.gender); err != nil &#123; // 如果出现错误，则记录错误信息并返回 log.Error(err) return\t&#125;\t// 输出查询到的用户信息\tlog.Info(user)&#125; 这是测试 MyGORM 库的数据库引擎功能。在测试函数中，首先创建了一个数据库引擎实例，并连接到 MySQL 数据库。然后获取一个数据库会话，并执行一条 SQL 查询，将查询结果中的第一行数据扫描到一个名为 User 的结构体中。最后输出查询到的用户信息。 执行 go test，将会看到如下的输出：","tags":[null,null,null],"categories":[null,null]},{"title":"Go连接Mysql","path":"/wiki/my-gorm/mysql.html","content":"本篇是Go从零实现ORM框架MyGORM的第一篇。 目的 MYSQL 的基础操作（连接数据库，创建表、增删记录等）。 使用 Go 语言标准库 database&#x2F;sql 连接并操作 MYSQL 数据库。 Go连接MYSQLGo原生提供了连接数据库操作的支持，在用 Golang进行开发的时候，如果需要在和数据库交互，则可以使用database&#x2F;sql包。这是一个对关系型数据库的通用抽象，它提供了标准的、轻量的、面向行的接口。 在Go中访问数据库需要用到sql.DB接口：它可以创建语句(statement)和事务(transaction)，执行查询，获取结果。 使用数据库时，除了database&#x2F;sql包本身，还需要引入想使用的特定数据库驱动，我使用的驱动为 github.com&#x2F;go-sql-driver&#x2F;mysql 建表在执行数据库操作前，先建一张数据表 mg_user.sql1234567CREATE TABLE `mg_user` ( `id` int unsigned NOT NULL AUTO_INCREMENT, `name` varchar(20) NOT NULL COMMENT &#x27;姓名&#x27;, `birthday` date NOT NULL COMMENT &#x27;出生日期&#x27;, `gender` tinyint unsigned NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;1男 2女 3保密&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci; 导包1go get github.com/go-sql-driver/mysql 初始化数据库连接main.go123456789101112131415161718192021222324252627package mainimport (\t&quot;database/sql&quot;\t&quot;fmt&quot;\t_ &quot;github.com/go-sql-driver/mysql&quot;)func main() &#123;\tdb, err := sql.Open(&quot;mysql&quot;, &quot;root:123456@tcp(127.0.0.1:3306)/my-gorm&quot;)\tif err != nil &#123; fmt.Println(err) return\t&#125;\t//设置与数据库的最大打开连接数\tdb.SetMaxOpenConns(100)\t//设置空闲中的最大连接数\tdb.SetMaxIdleConns(10)\tif err := db.Ping(); err != nil &#123; fmt.Println(&quot;打开数据库失败&quot;) return\t&#125;\tfmt.Println(&quot;数据库连接 success&quot;)&#125; 包名前面的”_”作用: 当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行init()函数而已。这个时候就可以使用 import _ 引用该包。 上面的mysql驱动中引入的就是mysql包中各个init()方法。 database&#x2F;sql简介 sql.Open()中的数据库连接串格式为：”用户名:密码@tcp(IP:端口)&#x2F;数据库?charset&#x3D;utf8”。 DB的类型为:*sql.DB，有了DB之后我们就可以执行CRUD操作。Go将数据库操作分为两类：Query与Exec。两者的区别在于前者会返回结果，而后者不会。 Query表示查询，它会从数据库获取查询结果（一系列行，可能为空）。Exec表示执行语句，它不会返回行。 此外还有两种常见的数据库操作模式：QueryRow表示只返回一行的查询，作为Query的一个常见特例。Prepare表示准备一个需要多次使用的语句，供后续执行用，通常用于批量处理语句。 查询操作123456789101112131415161718192021222324252627282930//发送查询到数据库，获取结果集Rowsrows, err := db.Query(&quot;SELECT * FROM mg_user&quot;)if err != nil &#123; fmt.Println(err) return&#125;//关闭结果集，释放连接。defer rows.Close()type User struct &#123; id int name string birthday string gender uint8&#125;var user User//作为循环条件，迭代读取结果集。for rows.Next() &#123; //Scan从结果集中获取一行结果。 err := rows.Scan(&amp;user.id, &amp;user.name, &amp;user.birthday, &amp;user.gender) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(user)&#125; 上面的操作流程如下： 使用db.Query()来发送查询到数据库，获取结果集Rows，并检查错误。 使用rows.Next()作为循环条件，迭代读取结果集。 使用rows.Scan从结果集中获取一行结果。 使用rows.Err()在退出迭代后检查错误。 使用rows.Close()关闭结果集，释放连接。 执行 go run main.go，输出如下: 123go run student.go数据库连接 success&#123;1 张三 1992-06-30 1&#125; 掌握了基础的 SQL 语句和 Go 标准库 database&#x2F;sql 的使用，可以开始实现 ORM 框架的雏形了。","tags":[null,null,null],"categories":[null,null]}]