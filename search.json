[{"title":"09.Mygin之错误恢复Recover中间件","path":"/2022/03/04/09-Mygin之错误恢复Recover中间件.html","content":"本篇是mygin这个系列的最后一篇。如果想自己动手实现一个类似Gin的Web框架，建议从 mgin第一篇开始，总代码行数有效行数只有600多行 github源码 mygin 目的 实现错误处理机制 panic简介在实现错误处理机制之前，我们知道在Go 中，错误的处理方式依靠return返回，由调用者处理。如果是不可恢复的错误，可以手动抛出错误，当然在实际运行中，也会遇到不可处理的错误，比如说除数为0的时候painc 也会触发。终止当前的程序。 手动触发错误123456//main.gofunc main() &#123; fmt.Println(&quot;before ....&quot;) panic(&quot;some err message&quot;) fmt.Println(&quot;after ....&quot;)&#125; shell12345678~ go run cmd/main.gobefore ....panic: some err messagegoroutine 1 [running]:main.main() /var/www/gophp/cmd/main.go:12 +0x5fexit status 2 程序发生错误12345func main() &#123; i := []int&#123;0&#125; j := 2 fmt.Println(j / i[0])&#125; shell1234567go run cmd/main.gopanic: runtime error: integer divide by zerogoroutine 1 [running]:main.main() /var/www/gophp/cmd/main.go:13 +0x194exit status 2 painc 的介绍到此为止，也就是发生了painc 错误，对程序来说就是比较严重的，就会中断，但是这个时候需要捕获到这个painc 错误，Go中没有try…Catch…又想捕获错误，这个时候就该defer 出场了。 defer简介panic会导致程序被中止，但是在程序终止前，会先把当前协程上已经defer的任务，执行完成后再终止。效果类似于其他语言的try…catch。 示例12345678910//cmd/main.gofunc main() &#123; defer func() &#123; fmt.Println(&quot;defer....&quot;) &#125;() i := []int&#123;0&#125; j := 2 fmt.Println(j / i[0])&#125; shell12345678~ go run cmd/main.godefer....panic: runtime error: integer divide by zerogoroutine 1 [running]:main.main() /var/www/gophp/cmd/main.go:16 +0x1d3exit status 2 可以看到，在程序退出之前先执行了defer 中的函数。如果能在defer 中捕获painc 错误，那么就能实现其他语言的try…catch recover函数介绍之前看官方文档怎么定义的 123456789101112131415// The recover built-in function allows a program to manage behavior of a// panicking goroutine. Executing a call to recover inside a deferred// function (but not any function called by it) stops the panicking sequence// by restoring normal execution and retrieves the error value passed to the// call of panic. If recover is called outside the deferred function it will// not stop a panicking sequence. In this case, or when the goroutine is not// panicking, or if the argument supplied to panic was nil, recover returns// nil. Thus the return value from recover reports whether the goroutine is// panicking.翻译后...recover 内置函数允许程序管理恐慌的 goroutine 的行为。在延迟函数（但不是它调用的任何函数）中执行恢复调用会通过恢复正常执行来停止 panic 序列，并检索传递给 panic 调用的错误值。如果在延迟函数之外调用 recover，则不会停止紧急序列。在这种情况下，或者当 goroutine 没有 panic 时，或者如果提供给 panic 的参数为 nil，则 recover 返回 nil。因此，recover 的返回值报告 goroutine 是否处于恐慌状态。 mygin应用 cmd&#x2F;main.go123456789101112func main() &#123; defer func() &#123; fmt.Println(&quot;defer....&quot;) if err := recover(); err != nil &#123; fmt.Printf(&quot;recover 到错误信息：%s &quot;, err.(error).Error()) fmt.Println(&quot;recover success&quot;) &#125; &#125;() i := []int&#123;0&#125; j := 2 fmt.Println(j / i[0]) fmt.Println(&quot;after panic&quot;) shell1234~ go run cmd/main.godefer....recover 到错误信息：runtime error: integer divide by zerorecover success 可以看到已经捕获到错误信息了，程序正常结束。 after panic 没有打印，这是正确的，当panic 被触发时，程序的执行栈就到定义的defer 函数。就像在try代码块中发生了异常，执行栈来到 catch，接下来执行 catch 代码块中的代码。而在 main() 中打印了 recover success，说明程序已经恢复正常，继续往下执行直到结束。 mygin的错误处理对一个 Web 框架而言，错误处理机制是必要的。如果发生了painc错误，应当返回错误信息或告诉对方失败了，而不至于什么都不返回，对调用方十分不友好。例如我有如下的逻辑 123456789101112131415161718192021222324252627package mainimport (\t&quot;fmt&quot;\t&quot;github.com/scott-pb/mygin&quot;\t&quot;net/http&quot;\t&quot;strconv&quot;)func main() &#123;\tr := mygin.Default()\tgroup := r.Group(&quot;/api&quot;)\tgroup.GET(&quot;/recovery/:index&quot;, func(c *mygin.Context) &#123; index := c.Params.ByName(&quot;index&quot;) i, _ := strconv.ParseInt(index, 10, 10) s := []int&#123;1, 3, 5, 7, 9&#125; c.String(http.StatusOK, fmt.Sprintf(&quot;index:%d result:%d success! &quot;, i, s[i]))\t&#125;)\terr := r.Run(&quot;:8088&quot;)\tif err != nil &#123; fmt.Println(err)\t&#125;&#125; 根据调用方传递的index下标函数数组中的值，当传递的index超过数组下标时，就会发生painc错误，如果执行&#x2F;api&#x2F;recovery&#x2F;10 时，就会发生错误。调用方什么返回都没有。这个时候，就需要添加一个错误的处理机制，当错误发生时，向调用方返回Internal Server Error，且打印必要的错误信息，方便进行错误定位。 实现中间件 Recovery新增文件 mygin&#x2F;recovery.go，在这个文件中实现中间件 Recovery mygin&#x2F;recovery.go123456789101112131415161718192021222324package myginimport (\t&quot;fmt&quot;\t&quot;net/http&quot;)// Recovery 发生错误时，恢复函数，且返回相应错误信息。func Recovery() HandlerFunc &#123;\treturn func(c *Context) &#123; // 使用defer延迟执行，以便在函数退出时进行recover defer func() &#123; if err := recover(); err != nil &#123; // 如果发生panic，打印错误信息并返回500 Internal Server Error响应 fmt.Println(err.(error).Error()) c.Writer.Write([]byte(&quot;Internal Server Error &quot;)) c.status = http.StatusInternalServerError c.Abort() // 终止后续中间件的执行 &#125; &#125;() c.Next() // 调用下一个中间件或处理函数\t&#125;&#125; Recovery 方法很简单，使用defer挂载上错误恢复的函数，在这个函数中调用 recover方法，捕获panic，打印错误信息，并且向调用方返回 Internal Server Error。 mygin&#x2F;engine.go123456789101112// Default 返回一个默认的引擎实例func Default() *Engine &#123;\tengine := New() //Logger Recovery 中间件\tengine.Use(Logger(), Recovery())\t// Group 保存 engine 的指针\tengine.RouterGroup.engine = engine\treturn engine&#125; 接下来就是测试了 测试 shell1234~ curl http://127.0.0.1:8088/api/recovery/1index:1 result:3 success!~ curl http://127.0.0.1:8088/api/recovery/10Internal Server Error 控制台输出可以看到第一次请求返回200成功，第二次请求，先打印了错误信息，然后对应的返回500错误，且调用方接收到了Internal Server Error。","tags":["Golang","Web"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"08.Mygin中间件优化及logger日志中间件","path":"/2022/03/02/08-Mygin中间件优化及logger日志中间件.html","content":"本篇是mygin的第八篇，参照gin框架，Mygin从零开始完全手写，在实现的同时，带你一窥gin框架的核心原理实现。 目的 中间件Middleware优化 默认log日志中间件在上篇 Mygin实现中间件Middleware 中间件Middleware很生硬，完全依赖循环，如果某个中间件想要cover住全部中间件，比如我想记录，整个请求的耗时时间，以便针对优化的功能。因此需要把之前生硬的方式做一些修改。 修改1.实例化上下文修改12345678//实例化一个下上文\tc := &amp;Context&#123; Request: r, Writer: w, Params: params, handlers: handlers, index: -1, //默认下标为-1\t&#125; 2.修改上下文Next方法12345678910// Next 执行链中的剩余处理程序。func (c *Context) Next() &#123;\tc.index++\t//遍历handlers\tfor c.index &lt; int8(len(c.handlers)) &#123; //真正调用执行handler方法 c.handlers[c.index](c) c.index++\t&#125;&#125; 日志参照(复制)gin中的写法，新建mygin&#x2F;logger.go日志中间件文件。 mygin&#x2F;logger.go1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package myginimport (\t&quot;fmt&quot;\t&quot;net/http&quot;\t&quot;time&quot;)const (\tgreen = &quot;\\033[97;42m&quot; // 绿色\twhite = &quot;\\033[90;47m&quot; // 白色\tyellow = &quot;\\033[90;43m&quot; // 黄色\tred = &quot;\\033[97;41m&quot; // 红色\tblue = &quot;\\033[97;44m&quot; // 蓝色\tmagenta = &quot;\\033[97;45m&quot; // 洋红色\tcyan = &quot;\\033[97;46m&quot; // 青色\treset = &quot;\\033[0m&quot; // 重置颜色)type LogFormatterParams struct &#123;&#125;// MethodColor 方法颜色获取func (l *LogFormatterParams) MethodColor(method string) string &#123;\tswitch method &#123;\tcase http.MethodGet: return blue\tcase http.MethodPost: return cyan\tcase http.MethodPut: return yellow\tcase http.MethodDelete: return red\tcase http.MethodPatch: return green\tcase http.MethodHead: return magenta\tcase http.MethodOptions: return white\tdefault: return reset\t&#125;&#125;// StatusCodeColor 状态颜色获取func (l *LogFormatterParams) StatusCodeColor(code int) string &#123;\tswitch &#123;\tcase code &gt;= http.StatusOK &amp;&amp; code &lt; http.StatusMultipleChoices: return green\tcase code &gt;= http.StatusMultipleChoices &amp;&amp; code &lt; http.StatusBadRequest: return white\tcase code &gt;= http.StatusBadRequest &amp;&amp; code &lt; http.StatusInternalServerError: return yellow\tdefault: return red\t&#125;&#125;// LoggerFunc 记录日志的方法func (l *LogFormatterParams) LoggerFunc() HandlerFunc &#123;\treturn func(context *Context) &#123; // 启动时间 start := time.Now() // 后续处理请求 context.Next() //后续处理请求 结束时间 now := time.Now() str := fmt.Sprintf(&quot;[MyGIN] %v |%s %3d %s| %13v |%s %-7s %s %#v &quot;, now.Format(&quot;2006/01/02 - 15:04:05&quot;), l.StatusCodeColor(context.status), context.status, reset, now.Sub(start), //耗时 l.MethodColor(context.Request.Method), context.Request.Method, reset, context.Request.URL.Path, ) fmt.Println(str)\t&#125;&#125; 日志中间件 测试测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041package myginimport (\t&quot;net/http&quot;\t&quot;path&quot;\t&quot;testing&quot;)func TestMyGin06(t *testing.T) &#123;\tr := Default()\tr.Use()\t//测试需要登录\tgroup := r.Group(&quot;/api&quot;, func(context *Context) &#123; //todo.... context.String(http.StatusOK, &quot;api Group 中间件失败了.... &quot;) context.Abort()\t&#125;)\tgroup.Use()\t//这个回调不会执行\tgroup.GET(&quot;/hello/:name&quot;, func(context *Context) &#123; name := context.Params.ByName(&quot;name&quot;) context.String(http.StatusOK, path.Join(&quot;hello &quot;, name, &quot;!&quot;))\t&#125;)\t//测试没有发生Abort\tgroup2 := r.Group(&quot;/api2&quot;, func(context *Context) &#123; //todo.... context.String(http.StatusOK, &quot;api Group 中间件成功了.... &quot;)\t&#125;)\t//这个回调会执行\tgroup2.GET(&quot;/hello2/:name&quot;, func(context *Context) &#123; name := context.Params.ByName(&quot;name&quot;) context.String(http.StatusOK, path.Join(&quot;hello2 &quot;, name, &quot;! &quot;))\t&#125;)\t// 启动服务器并监听端口\tr.Run(&quot;:8088&quot;)&#125; 启动测试1go test curl请求测试123456789101112131415curl -i http://localhost:8088/api2/hello2/scottHTTP/1.1 200 OKContent-Type: text/plain; charset=utf-8Date: Tue, 30 Jan 2024 06:56:03 GMTContent-Length: 49api Group 中间件成功了....hello2 /scott/!➜ ~ curl -i http://localhost:8088/api/hello/scottHTTP/1.1 200 OKContent-Type: text/plain; charset=utf-8Date: Tue, 30 Jan 2024 06:56:26 GMTContent-Length: 33api Group 中间件失败了.... 查看控制台输出","tags":["Golang","Web"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"07.Mygin中sync.Pool应用","path":"/2022/02/11/mygin-day07.html","content":"本篇是mygin的第六篇，参照gin框架，感兴趣的可以从 Mygin第一篇 开始看，Mygin从零开始完全手写，在实现的同时，带你一窥gin框架的核心原理实现。 目的 sync.Pool 的作用介绍 mygin中使用sync.Pool sync.Pool 的作用先看看官方文档怎样说的吧，我截取了官方文档的第一句。 12// A Pool is a set of temporary objects that may be individually saved and retrieved...... 简单翻译一下的意思是:池是一组可以单独保存和检索的临时对象。既然可以单独保存和检索的临时对象，对于大量重复地创建许多对象，造成 GC 的工作量巨大。而mygin的模式是 责任链模式 ,因此满足使用 sync.Pool。 一个 Pool 可以安全地由多个 goroutine 同时使用。池的目的是缓存已分配但未使用的项目以供以后重用，从而减轻垃圾回收器的压力。 sync.Pool 是可伸缩的，同时也是并发安全的，其大小仅受限于内存的大小。sync.Pool 用于存储那些被分配了但是没有被使用，而未来可能会使用的值。这样就可以不用再次经过内存分配，可直接复用已有对象，减轻 GC 的压力，从而提升系统的性能。以上都是源于官方文档翻译的，文档中还提到fmt包中，打印也使用了sync.Pool,感兴趣的可以点进源码查看。 sync.Pool 使用sync.Pool 的使用方式非常简单：只需要实现New函数即可。对象池中没有对象时，将会调用New函数创建,我使用了mygin中的context 创建12345var contextPool = sync.Pool&#123;\tNew: func() interface&#123;&#125; &#123; return new(Context)\t&#125;,&#125; 使用和归还123c := contextPool.Get().(*Context)json.Marshal(c)contextPool.Put(c) 测试123456789101112131415func BenchmarkUnmarshal(b *testing.B) &#123;\tfor n := 0; n &lt; b.N; n++ &#123; c := &amp;Context&#123;&#125; json.Marshal(c)\t&#125;&#125;func BenchmarkUnmarshalWithPool(b *testing.B) &#123;\tfor n := 0; n &lt; b.N; n++ &#123; c := contextPool.Get().(*Context) json.Marshal(c) contextPool.Put(c)\t&#125;&#125; 测试结果:123456789go test -bench . -benchmemgoos: linuxgoarch: amd64pkg: github.com/scott-pb/mygincpu: 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHzBenchmarkUnmarshal-8 5888780 208.1 ns/op 144 B/op 2 allocs/opBenchmarkUnmarshalWithPool-8 7261801 165.0 ns/op 48 B/op 1 allocs/opPASSok github.com/scott-pb/mygin 2.808s 在这个例子中，可以看出，使用了 sync.Pool 后，内存占用仅为未使用的 48&#x2F;144&#x3D; 1&#x2F;3，对 GC 的影响就很大了。执行速度也快了，当然不同的设备测试结果也会不同。 测试源码我把测试源码放在了mygin中 mygin&#x2F;context_test.go mygin使用sync.Pool修改mygin&#x2F;engine.go修改engine.go中实例化conetxt的部分具体在ServeHTTP 方法中 修改前12345678//实例化一个下上文c := &amp;Context&#123;\tRequest: r,\tWriter: w,\tParams: params,\thandlers: handlers,\tindex: -1,&#125; 修改后12345678910111213//从pool中取c := e.pool.Get().(*Context)c.Request = rc.Writer = wc.Params = paramsc.handlers = handlersc.index = -1// 执行处理函数链c.Next()//归还到pool中e.pool.Put(c) mygin测试main方法代码如下 123456789101112131415161718192021package mainimport (\t&quot;fmt&quot;\t&quot;github.com/scott-pb/mygin&quot;\t&quot;net/http&quot;)func main() &#123;\tr := mygin.Default()\tgroup := r.Group(&quot;/api&quot;)\tgroup.GET(&quot;/test&quot;, func(c *mygin.Context) &#123; c.String(http.StatusOK, &quot;success! &quot;)\t&#125;)\terr := r.Run(&quot;:8088&quot;)\tif err != nil &#123; fmt.Println(err)\t&#125;&#125; curl测试1234567curl -i http://localhost:8088/api/testHTTP/1.1 200 OKContent-Type: text/plain; charset=utf-8Date: Thu, 01 Feb 2024 05:08:52 GMTContent-Length: 9success! 这样mygin的context上下文就加入了Pool池，对于高并发情况下的GC压力会减轻不少。我设计的上下文中内容很少，随着功能的增多，效果会更加明显。","tags":["Golang","Web"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"06.Mygin实现中间件Middleware","path":"/2022/02/07/mygin-day06.html","content":"本篇是mygin的第六篇，参照gin框架，感兴趣的可以从 Mygin第一篇 开始看，Mygin从零开始完全手写，在实现的同时，带你一窥gin框架的核心原理实现。 目的 实现中间件Middleware在上一篇 Mygin实现分组路由Group 中，实现了路由分组，且同一分组的执行，会先执行Group，有一点点中间件的雏形了。但是中间件不完全还应该提供中断功能，比如一个Group组中添加了auth鉴权中间件，只有auth认证通过才可以通过，因此需要对上篇中的内容进行一些修改。在实现之前，先分析gin中是怎样去实现的这一功能的123456789func (c *Context) Next() &#123;\tc.index++ //遍历handlers\tfor c.index &lt; int8(len(c.handlers)) &#123; //真正调用执行handler方法 c.handlers[c.index](c) c.index++\t&#125;&#125; 这个时候就有疑问了，从上述方法中看不到中间件执行失败的中断方法，那又是怎么实现中断。在揭晓答案之前，先看看int8(len(c.handlers) 为什么要写个int8，原因在于gin中规定的handlers最多63个，相信实际的应用请求中，没有超过63个那么多变态的执行链。在gin中如果某一中间件执行失败，就把c.index赋值为63，上述for循环就不满足条件，因此就跳出for循环，不再继续执行后面的代码。gin中对应的代码也很简单。12345const abortIndex int8 = math.MaxInt8 &gt;&gt; 1//中间件执行失败，中断方法func (c *Context) Abort() &#123;\tc.index = abortIndex&#125; 因此只需在mygin&#x2F;content.go中新加Next方法和Abort方法 上下文content.go中的代码不多，索性加上注释全部贴出来。 mygin&#x2F;content.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package myginimport (\t&quot;encoding/json&quot;\t&quot;math&quot;\t&quot;net/http&quot;)// 定义 表示最大和上下文应中止时的索引值const abortIndex int8 = math.MaxInt8 &gt;&gt; 1// Context 封装了一个HTTP请求的上下文type Context struct &#123;\tRequest *http.Request\tWriter http.ResponseWriter\tParams Params\tindex int8&#125;// Next 执行链中的剩余处理程序。func (c *Context) Next(handlers HandlersChain) &#123;\t//遍历handlers\tfor c.index &lt; int8(len(handlers)) &#123; //真正调用执行handler方法 handlers[c.index](c) c.index++\t&#125;&#125;// Abort 中断链中剩余处理程序的执行。func (c *Context) Abort() &#123;\tc.index = abortIndex&#125;// IsAborted 如果当前上下文被中止，则返回true。func (c *Context) IsAborted() bool &#123;\treturn c.index &gt;= abortIndex&#125;// writeContentType 如果尚未设置，则设置Content-Type标头。func writeContentType(w http.ResponseWriter, value []string) &#123;\theader := w.Header()\tif val := header[&quot;Content-Type&quot;]; len(val) == 0 &#123; header[&quot;Content-Type&quot;] = value\t&#125;&#125;// Status 设置HTTP响应状态码。func (c *Context) Status(code int) &#123;\tc.Writer.WriteHeader(code)&#125;// JSON 将值序列化为JSON并将其写入响应。func (c *Context) JSON(v interface&#123;&#125;) error &#123;\twriteContentType(c.Writer, []string&#123;&quot;application/json; charset=utf-8&quot;&#125;)\tencoder := json.NewEncoder(c.Writer)\terr := encoder.Encode(v)\tif err != nil &#123; c.Status(http.StatusInternalServerError)\t&#125;\tc.Status(http.StatusOK)\treturn err&#125;// Html 将字符串以HTML形式写入响应。func (c *Context) Html(v string) error &#123;\twriteContentType(c.Writer, []string&#123;&quot;text/html; charset=utf-8&quot;&#125;)\tc.Status(http.StatusOK)\t_, err := c.Writer.Write([]byte(v))\treturn err&#125;// String 将字符串写入响应func (c *Context) String(v string) error &#123;\twriteContentType(c.Writer, []string&#123;&quot;text/plain; charset=utf-8&quot;&#125;)\tc.Status(http.StatusOK)\t_, err := c.Writer.Write([]byte(v))\treturn err&#125; 接下来就是调用handles的修改了，原来的解决方法是直接循环调用，对应的代码如下:1234567for _, handler := range handlers &#123; handler(&amp;Context&#123; Request: r, Writer: w, Params: params, &#125;)\t&#125; 引擎 mygin&#x2F;engine.go现在找到engine.go文件中将上面的代码替换为:12345678//实例化一个下上文c := &amp;Context&#123;\tRequest: r,\tWriter: w,\tParams: params,&#125;// 执行处理函数链c.Next(handlers) 测试代码1234567891011121314151617181920212223242526272829303132333435363738package mainimport (\t&quot;gophp/mygin&quot;\t&quot;path&quot;)func main() &#123;\t// 创建一个默认的 mygin 实例\tr := mygin.Default()\t//测试Abort\tgroup := r.Group(&quot;/api&quot;, func(context *mygin.Context) &#123; //todo.... context.String(&quot;api Group 中间件失败了.... &quot;) context.Abort()\t&#125;)\t//这个回调不会执行\tgroup.GET(&quot;/hello/:name&quot;, func(context *mygin.Context) &#123; name := context.Params.ByName(&quot;name&quot;) context.String(path.Join(&quot;hello &quot;, name, &quot;!&quot;))\t&#125;)\t//测试没有发生Abort\tgroup2 := r.Group(&quot;/api2&quot;, func(context *mygin.Context) &#123; //todo.... context.String(&quot;api Group 中间件成功了.... &quot;)\t&#125;) //这个回调会执行\tgroup2.GET(&quot;/hello2/:name&quot;, func(context *mygin.Context) &#123; name := context.Params.ByName(&quot;name&quot;) context.String(path.Join(&quot;hello2 &quot;, name, &quot;! &quot;))\t&#125;)\t// 启动服务器并监听端口\tr.Run(&quot;:8088&quot;)&#125; curl测试12345 curl http://127.0.0.1:8088/api/hello/scottapi Group 中间件失败了....~ curl http://127.0.0.1:8088/api2/hello2/scottapi Group 中间件成功了....hello2 /scott/! 看到上诉输出，即为成功。赶快去试试吧！","tags":["Golang","Web"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"05.Mygin实现分组路由Group","path":"/2022/01/31/mygin-day05.html","content":"本篇是Mygin第五篇 目的 实现路由分组 为什么要分组分组控制(Group Control)是 Web 框架应该提供的基础功能之一，对同一模块功能的开发，应该有相同的前缀。或者对一部分第三方接口，统一需要加解密等功能。分组后很方便。例如： 对于任务模块，统一前缀为&#x2F;task 除去&#x2F;user&#x2F;login接口，都需要鉴权 以&#x2F;openapi 开头的接口，需要对接第三方平台，需要三方平台鉴权 大多数分组都是统一前缀，正确的分组可以实现子分组，无限极往下分组，当然实际情况下也不会有太多层分组。每个分组有不同的中间件(middleware），分组与子分组就像洋葱一样，一层一层往内。要想往内，需要拨开最外层，也就是要执行外层的中间件才能往内。对于分组，也有后续扩展的好处，比如&#x2F;task分组，现在要统一加上访问日志记录，有了分组后就可以在该分组上添加一个中间件就可以了。 分组嵌套在实现分组嵌套之前，先看看gin中的分组嵌套是怎么实现的。gin中的分组中含有Engin的指针，其实很好理解，因为分组要有访问Router的能力。Engin中继承了RouterGroup，实例化Engin后就可以使用Group的功能。有了Engin的指针，整个框架的所有资源都是由Engine去统一调度的，因此通过Engine可以间接地拥有整个框架的功能。你中有我我中有你。 gin&#x2F;routergroup.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package myginimport (\t&quot;net/http&quot;\t&quot;path&quot;\t&quot;regexp&quot;)// IRoutes 定义了路由组的接口type IRoutes interface &#123;\tBasePath() string\tGET(string, ...HandlerFunc) IRoutes\tPOST(string, ...HandlerFunc) IRoutes\tDELETE(string, ...HandlerFunc) IRoutes\tPATCH(string, ...HandlerFunc) IRoutes\tPUT(string, ...HandlerFunc) IRoutes\tOPTIONS(string, ...HandlerFunc) IRoutes\tHEAD(string, ...HandlerFunc) IRoutes\tMatch([]string, string, ...HandlerFunc) IRoutes&#125;// anyMethods 包含所有 HTTP 方法的字符串表示var anyMethods = []string&#123;\thttp.MethodGet, http.MethodPost, http.MethodPut, http.MethodPatch,\thttp.MethodHead, http.MethodOptions, http.MethodDelete, http.MethodConnect,\thttp.MethodTrace,&#125;// RouterGroup 定义了路由组的结构体type RouterGroup struct &#123;\tHandlers HandlersChain // 路由组的中间件处理函数链\tbasePath string // 路由组的基础路径\tengine *Engine // 路由组所属的引擎\troot bool // 是否是根路由组&#125;// Group 创建一个新的路由组func (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup &#123;\treturn &amp;RouterGroup&#123; Handlers: append(group.Handlers, handlers...), basePath: path.Join(group.basePath, relativePath), engine: group.engine,\t&#125;&#125;// BasePath 返回路由组的基础路径func (group *RouterGroup) BasePath() string &#123;\treturn group.basePath&#125;// handle 处理路由，将路由信息添加到引擎中func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes &#123;\tabsolutePath := path.Join(group.basePath, relativePath) //处理函数，Group组定义的函数先执行，自定义的函数后执行\thandlers = append(group.Handlers, handlers...)\tgroup.engine.addRoute(httpMethod, absolutePath, handlers)\tif group.root &#123; return group.engine\t&#125;\treturn group&#125;// Handle 校验 HTTP 方法的有效性，并处理路由func (group *RouterGroup) Handle(httpMethod, relativePath string, handlers ...HandlerFunc) IRoutes &#123;\t// 检查 HTTP 方法的有效性\tif match := regexp.MustCompile(&quot;^[A-Z]+$&quot;).MatchString(httpMethod); !match &#123; panic(&quot;http method &quot; + httpMethod + &quot; is not valid&quot;)\t&#125;\t// 处理路由\treturn group.handle(httpMethod, relativePath, handlers)&#125;// GET 注册 GET 方法的路由func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes &#123;\treturn group.handle(http.MethodGet, relativePath, handlers)&#125;// POST 注册 POST 方法的路由func (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes &#123;\treturn group.handle(http.MethodPost, relativePath, handlers)&#125;// DELETE 注册 DELETE 方法的路由func (group *RouterGroup) DELETE(relativePath string, handlers ...HandlerFunc) IRoutes &#123;\treturn group.handle(http.MethodDelete, relativePath, handlers)&#125;// PATCH 注册 PATCH 方法的路由func (group *RouterGroup) PATCH(relativePath string, handlers ...HandlerFunc) IRoutes &#123;\treturn group.handle(http.MethodPatch, relativePath, handlers)&#125;// PUT 注册 PUT 方法的路由func (group *RouterGroup) PUT(relativePath string, handlers ...HandlerFunc) IRoutes &#123;\treturn group.handle(http.MethodPut, relativePath, handlers)&#125;// OPTIONS 注册 OPTIONS 方法的路由func (group *RouterGroup) OPTIONS(relativePath string, handlers ...HandlerFunc) IRoutes &#123;\treturn group.handle(http.MethodOptions, relativePath, handlers)&#125;// HEAD 注册 HEAD 方法的路由func (group *RouterGroup) HEAD(relativePath string, handlers ...HandlerFunc) IRoutes &#123;\treturn group.handle(http.MethodHead, relativePath, handlers)&#125;// Match 注册多个方法的路由func (group *RouterGroup) Match(methods []string, relativePath string, handlers ...HandlerFunc) IRoutes &#123;\tfor _, method := range methods &#123; group.handle(method, relativePath, handlers)\t&#125;\tif group.root &#123; return group.engine\t&#125;\treturn group&#125;// Any 注册所有方法的路由func (group *RouterGroup) Any(relativePath string, handlers ...HandlerFunc) IRoutes &#123;\tfor _, method := range anyMethods &#123; group.handle(method, relativePath, handlers)\t&#125;\tif group.root &#123; return group.engine\t&#125;\treturn group&#125; 可以看到group.engine.addRoute方法，实际调用的仍然是mygin&#x2F;router.go中的addRoute方法。当group.root为true，也就是为根时，相当于没有调用Group方法，返回group.engine，也就是相当于直接调用的engine，只有当调用Group方法后才会返回group。接下来看engine的修改 mygin&#x2F;engine.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package myginimport (\t&quot;net/http&quot;)// HandlerFunc 定义处理函数类型type HandlerFunc func(*Context)// HandlersChain 定义处理函数链类型type HandlersChain []HandlerFunc// Engine 定义引擎结构，包含路由器type Engine struct &#123;\tRouter\tRouterGroup&#125;// ServeHTTP 实现http.Handler接口的方法，用于处理HTTP请求func (e *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;\t// 获取对应HTTP方法的路由树的根节点\troot := e.trees.get(r.Method)\t// 解析请求路径\tparts := root.parseFullPath(r.URL.Path)\t// 查找符合条件的节点\tsearchNode := make([]*node, 0)\troot.search(parts, &amp;searchNode)\t// 没有匹配到路由\tif len(searchNode) == 0 &#123; w.Write([]byte(&quot;404 Not found! &quot;)) return\t&#125;\t// 参数赋值\tparams := make([]Param, 0)\tsearchPath := root.parseFullPath(searchNode[0].fullPath)\tfor i, sp := range searchPath &#123; if sp[0] == &#x27;:&#x27; &#123; params = append(params, Param&#123; Key: sp[1:], Value: parts[i], &#125;) &#125;\t&#125;\t// 获取处理函数链\thandlers := searchNode[0].handlers\tif handlers == nil &#123; w.Write([]byte(&quot;404 Not found! &quot;)) return\t&#125;\t// 执行处理函数链\tfor _, handler := range handlers &#123; handler(&amp;Context&#123; Request: r, Writer: w, Params: params, &#125;)\t&#125;&#125;// Default 返回一个默认的引擎实例func Default() *Engine &#123;\tengine := &amp;Engine&#123; Router: Router&#123; trees: make(methodTrees, 0, 9), &#125;, RouterGroup: RouterGroup&#123; Handlers: nil, basePath: &quot;/&quot;, root: true, &#125;,\t&#125;\t// Group 保存 engine 的指针\tengine.RouterGroup.engine = engine\treturn engine&#125;// Run 启动HTTP服务器的方法func (e *Engine) Run(addr string) error &#123;\treturn http.ListenAndServe(addr, e)&#125; 可以仔细观察下addRoute函数，调用了group.engine.router.addRoute来实现了路由的映射。由于Engine从某种意义上继承了RouterGroup的所有属性和方法，因为 (*Engine).engine 是指向自己的。这样实现，我们既可以像原来一样添加路由，也可以通过分组添加路由。 最后来测试一下 main.go12345678910111213141516171819202122232425262728package mainimport (\t&quot;gophp/mygin&quot;\t&quot;path&quot;)func main() &#123;\t// 创建一个默认的 mygin 实例\tr := mygin.Default()\tgroup := r.Group(&quot;/api&quot;, func(context *mygin.Context) &#123; context.String(&quot;api Group .... &quot;)\t&#125;)\tgroup.GET(&quot;/hello/:name&quot;, func(context *mygin.Context) &#123; name := context.Params.ByName(&quot;name&quot;) context.String(path.Join(&quot;hello &quot;, name, &quot;!&quot;))\t&#125;)\tgroup.GET(&quot;/hello2/:name&quot;, func(context *mygin.Context) &#123; name := context.Params.ByName(&quot;name&quot;) context.String(path.Join(&quot;hello2 &quot;, name, &quot;! &quot;))\t&#125;)\t// 启动服务器并监听端口\tr.Run(&quot;:8088&quot;)&#125; curl请求测试12345678910111213141516 curl -i http://localhost:8088/api/hello/scottHTTP/1.1 200 OKContent-Type: text/plain; charset=utf-8Date: Wed, 24 Jan 2024 05:16:45 GMTContent-Length: 29api Group ....hello /scott/!~ curl -i http://localhost:8088/api/hello2/scottHTTP/1.1 200 OKContent-Type: text/plain; charset=utf-8Date: Wed, 24 Jan 2024 05:16:54 GMTContent-Length: 31api Group ....hello2 /scott/! 可以看到两个路由都安装预定的返回了，即先返回Group定义的，再返回路由定义的。","tags":["Golang","Web"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"04.Mygin实现动态路由","path":"/2022/01/30/mygin-day04.html","content":"本篇是Mygin的第四篇 目的 使用 Trie 树实现动态路由解析。 参数绑定 前缀树本篇比前几篇要复杂一点，原来的路由是用map实现，索引非常高效，但是有一个弊端，键值对的存储的方式，只能用来索引静态路由。遇到类似hello&#x2F;:name这动态路由就无能为力了，实现动态路由最常用的数据结构，被称为前缀树。这种结构非常适用于路由匹配。比如我们定义了如下路由： &#x2F;a&#x2F;b&#x2F;c &#x2F;a&#x2F;b &#x2F;a&#x2F;c &#x2F;a&#x2F;b&#x2F;c&#x2F;d &#x2F;a&#x2F;:name&#x2F;c &#x2F;a&#x2F;:name&#x2F;c&#x2F;d &#x2F;a&#x2F;b&#x2F;:name&#x2F;e 在前缀树中的结构体 HTTP请求的路径是由&#x2F;分隔的字符串构成的,所以用&#x2F;拆分URL字符串，得到不同的树节点，且有对应的层级关系。 代码实现 Mygin&#x2F;tree.go 首先看tree中node结构定义12345678type node struct &#123;\tchildren []*node //子节点\tpart string //树节点\twildChild bool //是否是精确匹配\thandlers HandlersChain //路由回调，实际的请求\tnType nodeType //节点类型 默认static params\tfullPath string //完整路径&#125; 与普通的树不同，为了实现动态路由匹配，加上了wildChild这个参数。即当我们匹配 &#x2F;a&#x2F;scott&#x2F;c这个路由时，第一层节点，a精准匹配到了b，第二层节点，b模糊匹配到:name，那么将会把name这个参数赋值为scott，继续下一层匹配。我们将匹配的逻辑，包装为一个辅助函数。 Mygin&#x2F;tree.go 具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178package myginimport (\t&quot;strings&quot;)type nodeType uint8// 路由的类型const (\tstatic nodeType = iota\troot\tparam\tcatchAll)// 不同的method 对应不同的节点树 定义type methodTree struct &#123;\tmethod string\troot *node&#125;// Param 参数的类型key=&gt; valuetype Param struct &#123;\tKey string\tValue string&#125;// Params 切片type Params []Paramtype methodTrees []methodTreetype node struct &#123;\tchildren []*node\tpart string\twildChild bool\thandlers HandlersChain\tnType nodeType\tfullPath string&#125;// Get 获取 参数中的值func (ps Params) Get(name string) (string, bool) &#123;\tfor _, entry := range ps &#123; if entry.Key == name &#123; return entry.Value, true &#125;\t&#125;\treturn &quot;&quot;, false&#125;// ByName 通过ByName获取参数中的值 会忽略掉错误，默认返回 空字符串func (ps Params) ByName(name string) (v string) &#123;\tv, _ = ps.Get(name)\treturn&#125;// 根据method获取rootfunc (trees methodTrees) get(method string) *node &#123;\tfor _, tree := range trees &#123; if tree.method == method &#123; return tree.root &#125;\t&#125;\treturn nil&#125;// 添加路径时func (n *node) addRoute(path string, handlers HandlersChain) &#123;\t//根据请求路径按照&#x27;/&#x27;划分\tparts := n.parseFullPath(path)\t//将节点插入路由后，返回最后一个节点\tmatchNode := n.insert(parts)\t//最后的节点，绑定执行链\tmatchNode.handlers = handlers\t//最后的节点，绑定完全的URL，后续param时有用\tmatchNode.fullPath = path&#125;// 按照 &quot;/&quot; 拆分字符串func (n *node) parseFullPath(fullPath string) []string &#123;\tsplits := strings.Split(fullPath, &quot;/&quot;)\tparts := make([]string, 0)\tfor _, part := range splits &#123; if part != &quot;&quot; &#123; parts = append(parts, part) if part == &quot;*&quot; &#123; break &#125; &#125;\t&#125;\treturn parts&#125;// 根据路径 生成节点树func (n *node) insert(parts []string) *node &#123;\tpart := parts[0]\t//默认的字节类型为静态类型\tnt := static\t//根据前缀判断节点类型\tswitch part[0] &#123;\tcase &#x27;:&#x27;: nt = param\tcase &#x27;*&#x27;: nt = catchAll\t&#125;\t//插入的节点查找\tvar matchNode *node\tfor _, childNode := range n.children &#123; if childNode.part == part &#123; matchNode = childNode &#125;\t&#125;\t//如果即将插入的节点没有找到，则新建一个\tif matchNode == nil &#123; matchNode = &amp;node&#123; part: part, wildChild: part[0] == &#x27;*&#x27; || part[0] == &#x27;:&#x27;, nType: nt, &#125; //新子节点追加到当前的子节点中 n.children = append(n.children, matchNode)\t&#125;\t//当最后插入的节点时，类型赋值，且返回最后的节点\tif len(parts) == 1 &#123; matchNode.nType = nt return matchNode\t&#125;\t//匹配下一部分\tparts = parts[1:]\t//子节点继续插入剩余字部分\treturn matchNode.insert(parts)&#125;// 根据路由 查询符合条件的节点func (n *node) search(parts []string, searchNode *[]*node) &#123;\tpart := parts[0] //a\tallChild := n.matchChild(part) //b c :name\tif len(parts) == 1 &#123; // 如果到达路径末尾，将所有匹配的节点加入结果 *searchNode = append(*searchNode, allChild...) return\t&#125;\tparts = parts[1:] //b\tfor _, n2 := range allChild &#123; // 递归查找下一部分 n2.search(parts, searchNode)\t&#125;&#125;// 根据part 返回匹配成功的子节点func (n *node) matchChild(part string) []*node &#123;\tallChild := make([]*node, 0)\tfor _, child := range n.children &#123; if child.wildChild || child.part == part &#123; allChild = append(allChild, child) &#125;\t&#125;\treturn allChild&#125; 上诉路由中，实现了插入insert和匹配search时的功能，插入时安装拆分后的子节点，递归查找每一层的节点，如果没有匹配到当前part的节点，则新建一个。查询功能，同样也是递归查询每一层的节点。 Mygin&#x2F;router.go 12345678910111213141516171819202122232425262728293031323334353637package myginimport (\t&quot;net/http&quot;)type Router struct &#123;\ttrees methodTrees&#125;// 添加路由方法func (r *Router) addRoute(method, path string, handlers HandlersChain) &#123;\t//根据method获取root\trootTree := r.trees.get(method)\t//如果root为空\tif rootTree == nil &#123; //初始化一个root rootTree = &amp;node&#123;part: &quot;/&quot;, nType: root&#125; //将初始化后的root 加入tree树中 r.trees = append(r.trees, methodTree&#123;method: method, root: rootTree&#125;)\t&#125;\trootTree.addRoute(path, handlers)&#125;// Get Get方法func (r *Router) Get(path string, handlers ...HandlerFunc) &#123;\tr.addRoute(http.MethodGet, path, handlers)&#125;// Post Post方法func (e *Engine) Post(path string, handlers ...HandlerFunc) &#123;\te.addRoute(http.MethodPost, path, handlers)&#125; router中修改不大 Mygin&#x2F;engine.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package myginimport (\t&quot;net/http&quot;)// HandlerFunc 定义处理函数类型type HandlerFunc func(*Context)// HandlersChain 定义处理函数链类型type HandlersChain []HandlerFunc// Engine 定义引擎结构，包含路由器type Engine struct &#123;\tRouter&#125;// ServeHTTP 实现http.Handler接口的方法，用于处理HTTP请求func (e *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;\t// 获取对应HTTP方法的路由树的根节点\troot := e.trees.get(r.Method)\t// 解析请求路径\tparts := root.parseFullPath(r.URL.Path)\t// 查找符合条件的节点\tsearchNode := make([]*node, 0)\troot.search(parts, &amp;searchNode)\t// 没有匹配到路由\tif len(searchNode) == 0 &#123; w.Write([]byte(&quot;404 Not found! &quot;)) return\t&#125;\t// 参数赋值\tparams := make([]Param, 0)\tsearchPath := root.parseFullPath(searchNode[0].fullPath)\tfor i, sp := range searchPath &#123; if sp[0] == &#x27;:&#x27; &#123; params = append(params, Param&#123; Key: sp[1:], Value: parts[i], &#125;) &#125;\t&#125;\t// 获取处理函数链\thandlers := searchNode[0].handlers\tif handlers == nil &#123; w.Write([]byte(&quot;404 Not found! &quot;)) return\t&#125;\t// 执行处理函数链\tfor _, handler := range handlers &#123; handler(&amp;Context&#123; Request: r, Writer: w, Params: params, &#125;)\t&#125;&#125;// Default 返回一个默认的引擎实例func Default() *Engine &#123;\treturn &amp;Engine&#123; Router: Router&#123; trees: make(methodTrees, 0, 9), &#125;,\t&#125;&#125;// Run 启动HTTP服务器的方法func (e *Engine) Run(addr string) error &#123;\treturn http.ListenAndServe(addr, e)&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport (\t&quot;gophp/mygin&quot;)func main() &#123;\t// 创建一个默认的 mygin 实例\tr := mygin.Default()\t// 定义路由处理函数\thandleABC := func(context *mygin.Context) &#123; context.JSON(map[string]interface&#123;&#125;&#123; &quot;path&quot;: context.Request.URL.Path, &#125;)\t&#125;\t// 注册路由\tr.Get(&quot;/a/b/c&quot;, handleABC)\tr.Get(&quot;/a/b&quot;, handleABC)\tr.Get(&quot;/a/c&quot;, handleABC)\t// 注册带参数的路由\tr.Get(&quot;/a/:name/c&quot;, func(context *mygin.Context) &#123; name := context.Params.ByName(&quot;name&quot;) path := &quot;/a/&quot; + name + &quot;/c&quot; context.JSON(map[string]interface&#123;&#125;&#123; &quot;path&quot;: path, &#125;)\t&#125;)\tr.Get(&quot;/a/:name/c/d&quot;, func(context *mygin.Context) &#123; name := context.Params.ByName(&quot;name&quot;) path := &quot;/a/&quot; + name + &quot;/c/d&quot; context.JSON(map[string]interface&#123;&#125;&#123; &quot;path&quot;: path, &#125;)\t&#125;)\tr.Get(&quot;/a/b/:name/e&quot;, func(context *mygin.Context) &#123; name := context.Params.ByName(&quot;name&quot;) path := &quot;/a/b&quot; + name + &quot;/e&quot; context.JSON(map[string]interface&#123;&#125;&#123; &quot;path&quot;: path, &#125;)\t&#125;)\tr.Get(&quot;/a/b/c/d&quot;, handleABC)\t// 启动服务器并监听端口\tr.Run(&quot;:8088&quot;)&#125; 测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950curl -i http://localhost:8088/a/b/cHTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Tue, 23 Jan 2024 05:43:50 GMTContent-Length: 18&#123;&quot;path&quot;:&quot;/a/b/c&quot;&#125;➜ ~ curl -i http://localhost:8088/a/bHTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Tue, 23 Jan 2024 05:43:53 GMTContent-Length: 16&#123;&quot;path&quot;:&quot;/a/b&quot;&#125;➜ ~ curl -i http://localhost:8088/a/cHTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Tue, 23 Jan 2024 05:43:57 GMTContent-Length: 16&#123;&quot;path&quot;:&quot;/a/c&quot;&#125;➜ ~ curl -i http://localhost:8088/a/b/c/dHTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Tue, 23 Jan 2024 05:44:05 GMTContent-Length: 20&#123;&quot;path&quot;:&quot;/a/b/c/d&quot;&#125;➜ ~ curl -i http://localhost:8088/a/scott/cHTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Tue, 23 Jan 2024 05:45:16 GMTContent-Length: 22&#123;&quot;path&quot;:&quot;/a/scott/c&quot;&#125;➜ ~ curl -i http://localhost:8088/a/scott/c/dHTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Tue, 23 Jan 2024 05:45:22 GMTContent-Length: 24&#123;&quot;path&quot;:&quot;/a/scott/c/d&quot;&#125;➜ ~ curl -i http://localhost:8088/a/b/scott/eHTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Tue, 23 Jan 2024 05:45:32 GMTContent-Length: 23&#123;&quot;path&quot;:&quot;/a/bscott/e&quot;&#125;","tags":["Golang","Web"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"03.Mygin实现上下文","path":"/2022/01/28/mygin-day03.html","content":"本篇是Mygin的第三篇 目的 将路由独立出来，方便后续扩展修改 上下文Context，对http.ResponseWriter和http.Request进行封装，实现对JSON、HTML等的支持 路由新建一个router文件，将 Mygin实现简单的路由 中将路由部分复制出来 新建Mygin&#x2F;router.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package myginimport (\t&quot;log&quot;\t&quot;net/http&quot;)// 路由节点type methodTree struct &#123;\tmethod string\tpaths map[string]func(c *Context)&#125;type methodTrees map[string]methodTreetype Router struct &#123;\ttrees methodTrees&#125;// 获取路由root根func (r *Router) getRoot(method string) methodTree &#123;\tif root, ok := r.trees[method]; ok &#123; return root\t&#125;\tr.trees[method] = methodTree&#123;method: method, paths: make(map[string]func(c *Context))&#125;\treturn r.trees[method]&#125;// 添加路由方法func (r *Router) addRoute(method, path string, ctx func(c *Context)) &#123;\troot := r.getRoot(method)\tif _, ok := root.paths[path]; ok &#123; log.Default().Println(path, &quot;is exist&quot;) return\t&#125;\troot.method = method\troot.paths[path] = ctx&#125;// Get Get方法func (r *Router) Get(path string, handler func(c *Context)) &#123;\tr.addRoute(http.MethodGet, path, handler)&#125;// Post Post方法func (e *Engine) Post(path string, handler func(c *Context)) &#123;\te.addRoute(http.MethodPost, path, handler)&#125; 修改Mygin&#x2F;engine.go文件123456789101112131415161718192021222324252627282930313233343536package myginimport (\t&quot;net/http&quot;)type Engine struct &#123;\tRouter&#125;func (e *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;\tif tree, ok := e.trees[r.Method]; ok &#123; if handler, ok := tree.paths[r.URL.Path]; ok &#123; handler(w, r) return &#125;\t&#125;\tw.Write([]byte(&quot;404 Not found! &quot;))&#125;// Default returns an Enginefunc Default() *Engine &#123;\treturn &amp;Engine&#123; Router&#123; trees: make(methodTrees, 2), &#125;&#125;&#125;// Run 启动方法start a http serverfunc (e *Engine) Run(addr string) &#123;\terr := http.ListenAndServe(addr, e)\tif err != nil &#123; return\t&#125;&#125; 相当于engine继承router，engine可以调用router中的方法。文件拆分开来，就不那么乱了。以后路由相关的功能就在router文件中编写，更加清晰。 上下文对于1个请求来说，无法就是接收http.Request的数据处理，然后将处理后的数据http.ResponseWriter返回。虽然响应的消息体(Body)不一样，但对于同一种类型比如JSON类型，消息头(Header)和消息体(Body)，而 Header 包含了状态码(StatusCode)，消息类型(ContentType)等几乎每次请求都需要重新写，所以进行封装，对于后续扩展和修改都非常必要。 用返回 JSON 数据作比较，感受下封装前后的差距。 封装前 12345678910obj = map[string]interface&#123;&#125;&#123; &quot;name&quot;: &quot;scott&quot;, &quot;password&quot;: &quot;1234&quot;,&#125;w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)w.WriteHeader(http.StatusOK)encoder := json.NewEncoder(w)if err := encoder.Encode(obj); err != nil &#123; http.Error(w, err.Error(), 500)&#125; 封装后 1234c.JSON(http.StatusOK, map[string][string]&#123; &quot;username&quot;: c.PostForm(&quot;username&quot;), &quot;password&quot;: c.PostForm(&quot;password&quot;),&#125;) 封装http.Request和*http.ResponseWriter**的方法，简化相关接口的调用，只是设计 Context 的原因之一。对于框架来说，还需要支撑额外的功能。例如，将来解析动态路由&#x2F;hello&#x2F;:name，参数:name的值放在哪呢？再比如，框架需要支持中间件，那中间件产生的信息放在哪呢？Context 随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由 Context 承载。因此，设计 Context 结构，扩展性和复杂性留在了内部，而对外简化了接口。路由的处理函数，以及将要实现的中间件，参数都统一使用 Context 实例， Context 就像一次会话的百宝箱，可以找到任何东西。 新建mygin&#x2F;context.go文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package myginimport (\t&quot;encoding/json&quot;\t&quot;net/http&quot;)type Context struct &#123;\tRequest *http.Request\tWriter http.ResponseWriter&#125;func writeContentType(w http.ResponseWriter, value []string) &#123;\theader := w.Header()\tif val := header[&quot;Content-Type&quot;]; len(val) == 0 &#123; header[&quot;Content-Type&quot;] = value\t&#125;&#125;func (c *Context) Status(code int) &#123;\tc.Writer.WriteHeader(code)&#125;func (c *Context) JSON(v interface&#123;&#125;) error &#123;\twriteContentType(c.Writer, []string&#123;&quot;application/json; charset=utf-8&quot;&#125;)\tencoder := json.NewEncoder(c.Writer)\terr := encoder.Encode(v)\tif err != nil &#123; c.Status(http.StatusInternalServerError)\t&#125;\tc.Status(http.StatusOK)\treturn err&#125;func (c *Context) Html(v string) error &#123;\twriteContentType(c.Writer, []string&#123;&quot;text/html; charset=utf-8&quot;&#125;)\tc.Status(http.StatusOK)\t_, err := c.Writer.Write([]byte(v))\treturn err&#125;func (c *Context) String(v string) error &#123;\twriteContentType(c.Writer, []string&#123;&quot;text/plain; charset=utf-8&quot;&#125;)\tc.Status(http.StatusOK)\t_, err := c.Writer.Write([]byte(v))\treturn err&#125; 在context中实现了JSON、Html、String方法 main.go文件修改 12345678910111213141516171819202122232425package mainimport (\t&quot;gophp/mygin&quot;)func main() &#123;\tengine := mygin.Default()\tengine.Get(&quot;/json&quot;, func(c *mygin.Context) &#123; c.JSON(map[string]interface&#123;&#125;&#123; &quot;name&quot;: &quot;zs&quot;, &quot;password&quot;: &quot;1234&quot;, &#125;)\t&#125;)\tengine.Get(&quot;/html&quot;, func(c *mygin.Context) &#123; c.Html(&quot;&lt;h1&gt;hello html!&lt;/h1&gt;&quot;)\t&#125;)\tengine.Get(&quot;/string&quot;, func(c *mygin.Context) &#123; c.String(&quot;string...&quot;)\t&#125;)\tengine.Run(&quot;:9501&quot;)&#125; 接下来看实际效果 1234567891011121314151617181920212223curl -i http://localhost:9501/jsonHTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Wed, 17 Jan 2024 05:52:28 GMTContent-Length: 32&#123;&quot;name&quot;:&quot;zs&quot;,&quot;password&quot;:&quot;1234&quot;&#125; ~ curl -i http://localhost:9501/htmlHTTP/1.1 200 OKContent-Type: text/html; charset=utf-8Date: Wed, 17 Jan 2024 05:52:36 GMTContent-Length: 20&lt;h1&gt;hello html!&lt;/h1&gt; ~ curl -i http://localhost:9501/stringHTTP/1.1 200 OKContent-Type: text/plain; charset=utf-8Date: Wed, 17 Jan 2024 05:52:42 GMTContent-Length: 9string...","tags":["Golang","Web"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"02.Mygin实现简单的路由","path":"/2022/01/26/mygin-day02.html","content":"本文是Mygin第二篇 目的: 实现路由映射 提供了用户注册静态路由方法（GET、POST方法） 基于上一篇 Mygin 实现简单Http 且参照Gin 使用了map数组实现简单路由的映射关系 不同的method对应一个组，Gin框架初始化时map时初始化9个，因为支持的http.method刚好为9个 1234567891011121314package http//Gin 中对应的9个方法const (\tMethodGet = &quot;GET&quot;\tMethodHead = &quot;HEAD&quot;\tMethodPost = &quot;POST&quot;\tMethodPut = &quot;PUT&quot;\tMethodPatch = &quot;PATCH&quot; // RFC 5789\tMethodDelete = &quot;DELETE&quot;\tMethodConnect = &quot;CONNECT&quot;\tMethodOptions = &quot;OPTIONS&quot;\tMethodTrace = &quot;TRACE&quot;) mygin路由功能实现 mygin&#x2F;engine.go12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package myginimport (\t&quot;log&quot;\t&quot;net/http&quot;)type Engine struct &#123;\ttrees methodTrees&#125;// 路由树type methodTrees map[string]methodTree// 路由节点type methodTree struct &#123;\tmethod string\tpaths map[string]http.HandlerFunc&#125;// 获取路由root根func (e *Engine) getRoot(method string) methodTree &#123;\tif root, ok := e.trees[method]; ok &#123; return root\t&#125;\te.trees[method] = methodTree&#123;method: method, paths: make(map[string]http.HandlerFunc)&#125;\treturn e.trees[method]&#125;// 添加路由方法func (e *Engine) addRoute(method, path string, handler http.HandlerFunc) &#123;\troot := e.getRoot(method) //是否已经在路由数上绑定，如果已经绑定就不在继续绑定\tif _, ok := root.paths[path]; ok &#123; log.Default().Println(path, &quot;is exist&quot;) return\t&#125; //将path与处理方法关系绑定\troot.method = method\troot.paths[path] = handler&#125;func (e *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; //对应method中的路由树\tif tree, ok := e.trees[r.Method]; ok &#123; //路由数中path映射 if handler, ok := tree.paths[r.URL.Path]; ok &#123; handler(w, r) return &#125;\t&#125; //在路由数中没有找到对应的路由\tw.Write([]byte(&quot;404 Not found! &quot;))&#125;// Get Get方法func (e *Engine) Get(path string, handler http.HandlerFunc) &#123;\te.addRoute(http.MethodGet, path, handler)&#125;// Post Post方法func (e *Engine) Post(path string, handler http.HandlerFunc) &#123;\te.addRoute(http.MethodPost, path, handler)&#125;// Default returns an Enginefunc Default() *Engine &#123;\treturn &amp;Engine&#123;trees: make(methodTrees, 2)&#125;&#125;// Run 启动方法start a http serverfunc (e *Engine) Run(addr string) &#123;\terr := http.ListenAndServe(addr, e)\tif err != nil &#123; return\t&#125;&#125; 我们重点介绍一下这部分的实现 首先定义了类型methodTrees，这是提供给框架用户的，用来定义路由映射的处理方法。我们在Engine中，添加了一张路由映射表router，key 由请求方法和静态路由地址构成，例如GET请求 “&#x2F;“ 在methodTrees中methodTrees[“GET”][“&#x2F;“]、”&#x2F;hello”&#x3D;&gt;methodTrees[“GET”][“&#x2F;hello”]、”&#x2F;hello”&#x3D;&gt;methodTrees[“POST”][“&#x2F;hello”]，这样针对相同的路由，如果请求方法不同,可以映射不同的处理方法(Handler)，value 是用户映射的处理方法。 当用户调用(*Engine).Get()方法时，会将路由和处理方法注册到映射表 router 中，(*Engine).Run()方法，是 ListenAndServe 的包装。 Engine实现的 ServeHTTP 方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法。如果查不到，就返回 **404 Not found!**。 mai测试n方法调用1234567891011121314151617181920package mainimport (\t&quot;mygin&quot;\t&quot;net/http&quot;)func main() &#123;\tengine := mygin.Default() engine.Get(&quot;/hello&quot;, func(writer http.ResponseWriter, request *http.Request) &#123; writer.Write([]byte(&quot;Mygin Get hello method&quot;))\t&#125;)\tengine.Post(&quot;/hello&quot;, func(writer http.ResponseWriter, request *http.Request) &#123; writer.Write([]byte(&quot;Mygin Post hello method&quot;))\t&#125;)\tengine.Run(&quot;:8088&quot;)&#125; curl请求测试123456~ curl 127.0.0.1:8088/helloMygin Get hello method#~ curl -X POST http://127.0.0.1:8088/helloMygin Post hello method# ~ curl -X POST http://127.0.0.1:8088/hello2404 Not found! 至此，整个Mygin框架的原型已经出来了。实现了路由映射表，提供了用户注册静态路由的方法，包装了启动服务的函数。当然，到目前为止，我们还没有实现比net&#x2F;http标准库更强大的能力，不用担心，很快就可以将动态路由、中间件等功能添加上去了。","tags":["Golang","Web"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"01.Mygin实现简单Http","path":"/2022/01/24/mygin-day01.html","content":"本篇是完全参考gin的功能，自己手动实现一个类似的功能，帮助自己理解和学习gin框架。目的:简单介绍net&#x2F;http库以及http.Handler接口,实现简单路由请求的功能。 目的 简单介绍net&#x2F;http库以及http.Handler接口 实现简单路由请求的功能 标准库启动Web服务先看用标准库怎样启动一个web服务 123456789import &quot;net/http&quot;func helloHandler(w http.ResponseWriter, r *http.Request) &#123;\tw.Write([]byte(&quot;hello world&quot;))&#125;func main() &#123;\thttp.HandleFunc(&quot;/hello&quot;, helloHandler)\thttp.ListenAndServe(&quot;:8088&quot;, nil)&#125; 设置路由我设置了一个 &#x2F;hello 的简单路由，GET请求后返回 hello world。 12 ~ curl 127.0.0.1:8088/hellohello world为什么请求路由能够返回hello world，这就要从Golang的http包ListenAndServe.go中查看了。 ListenAndServe源码查看我已经将源码上的注释翻译成了中文 1234567891011// ListenAndServe监听TCP网络地址addr，然后调用//使用处理程序处理传入连接的请求。//被接受的连接被配置为使能TCP keepalive。////处理程序通常为nil，在这种情况下使用DefaultServeMux。//// ListenAndServe总是返回一个非nil错误。func ListenAndServe(addr string, handler Handler) error &#123;\tserver := &amp;Server&#123;Addr: addr, Handler: handler&#125;\treturn server.ListenAndServe()&#125; 实现Handler接口 http包中HandleFunc的第二个参数是什么意思？点进官方包去看。12345package httptype Handler interface &#123; ServeHTTP(w ResponseWriter, r *Request)&#125; 看到第二个参数是要实现 Handler 接口的方法，根据路由匹配交给实现对应的方法处理。 engine.go编写基于此改造封装mygin&#x2F;engine.go 12345678910111213141516171819202122232425262728293031package myginimport (\t&quot;net/http&quot;)type Engine struct &#123;&#125;//ServeHTTP 方法func (e *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;\tswitch r.URL.Path &#123;\tcase &quot;/&quot;: w.Write([]byte(&quot;success &quot;))\tcase &quot;/hello&quot;: w.Write([]byte(&quot;hello world！ &quot;))\tdefault: w.Write([]byte(&quot;404 NOT FOUND&quot; + r.URL.Path + &quot; &quot;))\t&#125;&#125;func Default() *Engine &#123;\treturn &amp;Engine&#123;&#125;&#125;func (e *Engine) Run(addr string) &#123;\terr := http.ListenAndServe(addr, e)\tif err != nil &#123; return\t&#125;&#125; 可以看到我编写了一个engine.go文件，包含了ServeHTTP方法，也就是engine实现了http包中 Handler 接口。http.ListenAndServe第二个参数把engine对象传过去，在http在处理时，就会去调用engine中的ServeHTTP方法。 main.go中调用12345678package mainimport &quot;gophp/mygin&quot;func main() &#123;\tengine := mygin.Default()\tengine.Run(&quot;:8088&quot;)&#125; 编写好上诉代码后，启动main方法，可以看到我将 :8088当作地址传入调用engine.go中的Run方法，将 :8088 当作第一个参数传入http.ListenAndServe中，表示监听8088端口，第二个参数则是我们基于net&#x2F;http标准库实现Web框架的入口，也就是engine中的ServeHTTP方法。 curl请求1234 ~ curl 127.0.0.1:8088/hellohello world！ ~ curl 127.0.0.1:8088success 看到上诉结果，代表已经实现了最核心的第一步，在Golang中，不管什么web框架，所有的请求都是在此基础上运行的。赶快去试试吧。","tags":["Golang","Web","Mygin"],"categories":["Go从零实现Web框架Mygin教程"]},{"title":"About - pengbin","path":"/about/index.html","content":"关于我 教育背景西南科技大学&emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; 2016年毕业 工作经验2022年10月 ~ 至今：重庆药羚科技有限公司 主要负责前期项目架构设计公共组件封装。 也负责测试用例设计，指导组内成员，进行辅导和监督。 2020年10月 ~ 2022年10月：重庆优税猫科技公司 主要负责项目的搭建和主要功能模块的开发和优化 也负责日常的功能开发及优化 负责协调解决系统出现的bug 2018年3月 ~ 2022年10月：重庆国贵赛车科技公司 主要负责项目 也负责XXX 2016年10月 ~ 2018年3月：重庆龙易购科技公司 主要负责XXX 也负责XXX 精选项目PMS项目2000&#x2F;01 ~ 2019&#x2F;01：于重庆药羚科技有限公司开发，团队项目，维护至今啦啦啦 B项目1900&#x2F;01 ~ 2000&#x2F;01：于XX公司开发啦啦啦 C项目1800&#x2F;01 ~ 1900&#x2F;01：于XX公司开发啦啦啦 与我联系目前状态为：在职，考虑换工作，100年内可到岗。 &#x70;&#x65;&#x6e;&#x67;&#x62;&#105;&#110;&#x5f;&#50;&#48;&#49;&#x32;&#64;&#x31;&#54;&#x33;&#46;&#99;&#111;&#109;"},{"path":"/wiki/index.html","content":"写在前面欢迎来到我的笔记小站！ 终生学习的重要性不言而喻，培根说过：To live is to learn, to learn is not to live。意思是【活着就要学习，学习不是为了活着】。 所以在有生之年，我将把我想学的知识系统地记录在这里，也希望能对你有帮助。"}]